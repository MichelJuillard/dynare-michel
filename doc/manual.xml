<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
  <bookinfo>
    <title>Dynare Manual</title>
    <subtitle>Version 4.1.0</subtitle>
    <author>
      <firstname>Stéphane</firstname><surname>Adjemian</surname>
      <affiliation><orgname>Université du Mans et CEPREMAP</orgname></affiliation>
      <email>stephane.adjemian@ens.fr</email>
      <address><street>142 rue du Chevaleret</street><postcode>75013</postcode><city>Paris</city><country>France</country></address>
    </author>
    <author>
      <firstname>Michel</firstname><surname>Juillard</surname>
      <affiliation><orgname>Banque de France and CEPREMAP</orgname></affiliation>
      <email>michel.juillard@ens.fr</email>
      <address><street>142 rue du Chevaleret</street><postcode>75013</postcode><city>Paris</city><country>France</country></address>
    </author>
    <author>
      <firstname>Ferhat</firstname><surname>Mihoubi</surname>
      <affiliation><orgname>Université d'Évry and CEPREMAP</orgname></affiliation>
      <email>fmihoubi@univ-evry.fr</email>
      <address><street>142 rue du Chevaleret</street><postcode>75013</postcode><city>Paris</city><country>France</country></address>
    </author>
    <author>
      <firstname>George</firstname><surname>Perendia</surname>
      <affiliation><orgname>CEPREMAP</orgname></affiliation>
      <email>george@perendia.orangehome.co.uk</email>
      <address><street>142 rue du Chevaleret</street><postcode>75013</postcode><city>Paris</city><country>France</country></address>
    </author>
    <author>
      <firstname>Sébastien</firstname><surname>Villemot</surname>
      <affiliation><orgname>Banque de France and CEPREMAP</orgname></affiliation>
      <email>sebastien.villemot@ens.fr</email>
      <address><street>142 rue du Chevaleret</street><postcode>75013</postcode><city>Paris</city><country>France</country></address>
    </author>

    <copyright><year>1996-2009</year><holder>Dynare Team</holder></copyright>

<legalnotice>
<para>
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
</para>
<para>
A copy of the license can be found at:
<ulink url="http://www.gnu.org/licenses/fdl.txt">http://www.gnu.org/licenses/fdl.txt</ulink>
</para>
</legalnotice>
  </bookinfo>

<chapter><title>Introduction</title>

<sect1><title>What is Dynare ?</title>
<para>
Dynare is a pre-processor and a collection of <ulink url="http://www.mathworks.com/products/matlab/"><trademark class="registered">MATLAB</trademark></ulink> and <ulink url="http://www.octave.org">GNU Octave</ulink> routines which solve, simulate and estimate non-linear
models with forward looking variables. It is the result of research carried at
<ulink url="http://www.cepremap.ens.fr/">CEPREMAP</ulink> by several people (see <xref linkend="laffargue_1990"/>,
<xref linkend="boucekkine_1995"/>, <xref linkend="juillard_1996"/>, <xref linkend="collard-juillard_2001a" /> and <xref linkend="collard-juillard_2001b"/>).
</para>
<para>
When the framework is deterministic, Dynare can be used for models with the assumption of perfect
foresight. Typically, the system is supposed to be in a state of
equilibrium before a period <literal>1</literal> when the news of a contemporaneous
or of a future shock is learned by the agents in the model. The
purpose of the simulation is to describe the reaction in anticipation of,
then in reaction to the shock, until the system returns to the old or
to a new state of equilibrium. In most models, this return to
equilibrium is only an asymptotic phenomenon, which one must
approximate by an horizon of simulation far enough in the future.
Another exercise for which Dynare is well suited is to study the
transition path to a new equilibrium following a permanent shock.
</para>
<para>
For deterministic simulations, Dynare uses a Newton-type algorithm, first
proposed by <xref linkend="laffargue_1990"/>, instead of a first order technique like
the one proposed by <xref linkend="fair-taylor_1983"/>, and used in earlier generation simulation programs. We believe
this approach to be in general both faster and more robust. The
details of the algorithm used in Dynare can be found in <xref linkend="juillard_1996"/>.
</para>
<para>
In a stochastic context, Dynare computes one or several simulations corresponding to a random draw of the shocks. Starting with version 2.3, Dynare uses a second order Taylor approximation of the expectation functions (see <xref linkend="judd_1996"/>, 
<xref linkend="collard-juillard_2001a" />, <xref linkend="collard-juillard_2001b"/>, and <xref linkend="schmitt-grohe-uribe_2002"/>).
</para>
<para>
Starting with version 3.0, it is possible to use Dynare to estimate model parameters either by maximum likelihood as in <xref linkend="ireland_2004"/> or using a Bayesian approach as in <xref linkend="rabanal-rubio-ramirez_2003"/>, <xref linkend="schorfheide_2000"/> or <xref linkend="smets-wouters_2003"/>.
</para>

<para>
Currently the development team of Dynare is composed of S. Adjemian, H. Bastani, M. Juillard, F. Mihoubi, G. Perendia, M. Ratto and S. Villemot. Several parts of Dynare use or have strongly benefited from publicly available programs by G. Anderson, F. Collard, L. Ingber, O. Kamenik, P. Klein, S. Sakata, F. Schorfheide, C. Sims, P. Soederlind and R. Wouters.  
</para>
</sect1>

</chapter>

<chapter><title>Installation and configuration</title>


<sect1 id="software-requirements"><title>Software requirements</title>
<para>
Packaged versions of Dynare are available for <trademark class="registered">Windows</trademark> XP/Vista, <ulink url="http://www.debian.org">Debian GNU/Linux</ulink> and <ulink url="http://www.ubuntu.com/">Ubuntu</ulink>.
Dynare should work on other systems, but some compilation steps are necessary in that case.
</para>
<para>In order to run Dynare, you need at least one of the following:
<itemizedlist>
<listitem><para><trademark class="registered">MATLAB</trademark> version 6.5 or above; note that no toolbox is needed by Dynare,</para></listitem>
<listitem><para>GNU Octave version 3.0.0 or above.</para></listitem>
</itemizedlist>
</para>

<para>Some installation instructions for GNU Octave can be found on <ulink url="http://www.dynare.org/DynareWiki/DynareOctave">Dynare Wiki</ulink>.</para>

<para>If you are using MATLAB for Windows, and if you plan to use options <xref linkend="use_dll"/> (in particular when computing third order approximations with <xref linkend="k_order_solver"/>), you will need to install a C++ compiler on your machine, and configure it with MATLAB: see <ulink url="http://www.dynare.org/DynareWiki/ConfigureMatlabWindowsForMexCompilation">instructions on the Dynare wiki</ulink>. Users of MATLAB under Linux and MacOS, and users of GNU Octave normally need to do nothing, since a working compilation environment is available by default.</para>

</sect1>

<sect1><title>Installation of Dynare</title>

<para>
After installation, Dynare can be used in any directory on your computer. It is best practive to keep your model files in directories different from the one containing the Dynare toolbox. That way you can upgrade Dynare and discard the previous version without having to worry about your own files.
</para>

<sect2><title>On <trademark class="registered">Windows</trademark></title>

<para>Execute the automated installer called <filename>dynare-4.x.y-win.exe</filename> (where 4.x.y is the version number), and follow the instructions. The default installation directory is <filename>c:\dynare\4.x.y</filename>.</para>

<para>After installation, this directory will contain several sub-directories, among which <filename>matlab</filename>, <filename>mex</filename> and <filename>doc</filename>.</para>

<para>The installer will also add an entry in your Start Menu with a shortcut to documentation files and to the uninstaller.</para>

<para>You can have several versions of Dynare coexisting (for example in <filename>c:\dynare</filename>), as long as you correctly adjust your path settings (see <xref linkend="path_warning" />).</para>

</sect2>

<sect2><title>On Debian GNU/Linux and Ubuntu</title>
<para>Please refer to <ulink url="http://www.dynare.org/DynareWiki/InstallOnDebianOrUbuntu">Dynare Wiki</ulink> for detailed instructions.</para>

<para>Dynare will be installed under <filename>/usr/share/dynare</filename> and <filename>/usr/lib/dynare</filename>. Documentation will be under <filename>/usr/share/doc/dynare</filename>.</para>
</sect2>

<sect2 id="install_other_systems"><title>For other systems</title>
<para>You need to download Dynare source code from the <ulink url="http://www.dynare.org">Dynare website</ulink> and unpack it somewhere.</para>

<para>Then you will need to recompile the pre-processor and the dynamic loadable libraries. Please refer to <ulink url="http://www.dynare.org/DynareWiki/BuildingDynareFromSource">Dynare Wiki</ulink>.</para>
</sect2>
</sect1>

<sect1><title>Configuration</title>

<sect2><title>For <trademark class="registered">MATLAB</trademark></title>

<para>You need to add the <filename>matlab</filename> subdirectory of your Dynare
installation to <trademark class="registered">MATLAB</trademark> path. You have two options for doing that:</para>
<itemizedlist>

  <listitem><para>Using the <command>addpath</command> command in the <trademark class="registered">MATLAB</trademark> command window:</para>

  <para>Under <trademark class="registered">Windows</trademark>, assuming that you have installed Dynare at the standard location, and replacing "4.x.y" by correct version number, type:</para>
  <programlisting>
  addpath c:\dynare\4.x.y\matlab
  </programlisting>

  <para>Under Debian GNU/Linux or Ubuntu, type:</para>
  <programlisting>
   addpath /usr/share/dynare/matlab
  </programlisting>

 <para><trademark class="registered">MATLAB</trademark> will not remember this setting next time you run it, and you will have
 to do it again.</para>
 </listitem>
  <listitem><para>Via the menu entries:</para>
<para>Select the "Set Path" entry in the "File" menu, then click on "Add
  Folder...", and select the <filename>matlab</filename> subdirectory of your Dynare
  installation. Note that you <emphasis>should not</emphasis> use "Add with Subfolders...". Apply
  the settings by clicking on "Save". Note that <trademark class="registered">MATLAB</trademark> will remember this
  setting next time you run it.</para></listitem>
</itemizedlist>
</sect2>

<sect2><title>For GNU Octave</title>

<para>You need to add the <filename>matlab</filename> subdirectory of your Dynare
installation to Octave path, using the <command>addpath</command> at the Octave command prompt.</para>

<para>Under <trademark class="registered">Windows</trademark>, assuming that you have installed Dynare at the standard location, and replacing "4.x.y" by correct version number, type:</para>
<programlisting>
  addpath c:\dynare\4.x.y\matlab
</programlisting>

<para>Under Debian GNU/Linux or Ubuntu, there is no need to use the <command>addpath</command> command; the packaging does it for you.</para>

<para>If you are using an Octave version strictly older than 3.2.0, you will also want to tell to Octave to accept the short syntax (without parentheses and quotes) for the <command>dynare</command> command, by typing:</para>
<programlisting>
  mark_as_command dynare
</programlisting>
<para>If you don't want to type this command every time you run Octave,
you can put it in a file called <filename>.octaverc</filename> in your home directory (under <trademark class="registered">Windows</trademark> this will generally by <filename>c:\Documents and Settings\USERNAME\</filename>). This file is run by Octave at every startup.</para>
</sect2>

<sect2 id="path_warning"><title>Some words of warning</title>

<para>You should be very careful about the content of you <trademark class="registered">MATLAB</trademark> or Octave path. You can display its content by simply typing <command>path</command> in the command window.</para>

<para>The path should normally contain system directories of <trademark class="registered">MATLAB</trademark> or Octave, and some subdirectories of your Dynare installation. You have to manually add the <filename>matlab</filename> subdirectory, and Dynare will automatically add a few other subdirectories at runtime (depending on your configuration). You must verify that there is no directory coming from another version of Dynare than the one you are planning to use.</para>

<para>You have to be aware that adding other directories to your path can potentially create problems, if some of your M-files have the same names than Dynare files. Your files would then override Dynare files, and make Dynare unusable.</para>
</sect2>

</sect1>
</chapter>

<chapter><title>Dynare invocation</title>

<para>
In order to give instructions to Dynare, the user has to write a <emphasis>model file</emphasis> whose filename extension must be <filename class="extension">.mod</filename>. This file contains the description of the model and the computing tasks required by the user. Its contents is described in <xref linkend="modfile"/>.
</para>

<para>Once the model file is written, Dynare is invoked using the <command>dynare</command> command at the <trademark class="registered">MATLAB</trademark> or Octave prompt (with the filename of the <filename class="extension">.mod</filename> given as argument).</para>

<para>
In practice, the handling of the model file is done in two
steps: in the first one, the model and the processing instructions
written by the user in a <emphasis>model file</emphasis> are
interpreted and the proper <trademark class="registered">MATLAB</trademark> or GNU Octave instructions are generated; in the
second step, the program actually runs the computations. Boths steps are triggered automatically by the <command>dynare</command> command.
</para>

<refentry id="dynare">
  <refmeta>
    <refentrytitle>dynare</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>dynare</refname>
    <refpurpose>executes Dynare</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>dynare</command>
      <arg choice="plain">
      <replaceable>FILENAME</replaceable>[.mod]
      </arg>
      <arg><option>noclearall</option></arg>
      <arg><option>debug</option></arg>
      <arg><option>notmpterms</option></arg>
      <arg><option>savemacro</option><arg>=<replaceable>FILENAME</replaceable></arg></arg>
      <arg><option>onlymacro</option></arg>
      <arg><option>nolinemacro</option></arg>
      <arg><option>warn_uninit</option></arg>
      <arg><option>cygwin</option></arg>
      <arg><option>msvc</option></arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
<command>dynare</command> executes instruction included in <replaceable>FILENAME</replaceable><filename class="extension">.mod</filename>.
This user-supplied file contains the model and the processing instructions, as described in <xref linkend="modfile"/>.
</para>
</refsect1>

<refsect1><title>Details</title>
<para>
<command>dynare</command> begins by launching the preprocessor on the <filename class="extension">.mod</filename> file.

By default (unless <option>use_dll</option> option has been given to <xref linkend="model"/>), the preprocessor creates three intermediary files:
<variablelist>
  <varlistentry>
    <term><replaceable>FILENAME</replaceable><filename>.m</filename></term>
    <listitem><para>Contains variable declarations, and computing tasks</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><replaceable>FILENAME</replaceable><filename>_dynamic.m</filename></term>
    <listitem><para>Contains the dynamic model equations</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><replaceable>FILENAME</replaceable><filename>_static.m</filename></term>
    <listitem><para>Contains the long run static model equations</para></listitem>
    </varlistentry>
</variablelist>
These files may be looked at to understand errors reported at the simulation stage.
</para>
<para><command>dynare</command> will then run the computing tasks by executing <replaceable>FILENAME</replaceable><filename>.m</filename>.</para>
</refsect1>

<refsect1><title>Options</title>

  <variablelist>
    <varlistentry>
      <term><option>noclearall</option></term>
      <listitem><para>By default, <command>dynare</command> will issue a <command>clear all</command> command to <trademark class="registered">MATLAB</trademark> or Octave, thereby deleting all workspace variables; this options instructs <command>dynare</command> not to clear the workspace</para></listitem>
    </varlistentry>
    <varlistentry>
      <term><option>debug</option></term>
      <listitem><para>Instructs the preprocessor to write some debugging information about the scanning and parsing of the <filename class="extension">.mod</filename> file</para></listitem>
    </varlistentry>
    <varlistentry>
      <term><option>notmpterms</option></term>
      <listitem><para>Instructs the preprocessor to omit temporary terms in the static and dynamic files; this generally decreases performance, but is used for debugging purposes since it makes the static and dynamic files more readable</para></listitem>
    </varlistentry>
    <varlistentry>
      <term><option>savemacro</option>[=<replaceable>FILENAME</replaceable>]</term>
      <listitem><para>Instructs <command>dynare</command> to save the intermediary file which is obtained after macro-processing (see <xref linkend="macrolanguage"/>); the saved output will go in the file specified, or if no file is specified in <replaceable>FILENAME</replaceable><filename>-macroexp.mod</filename></para></listitem>
    </varlistentry>
    <varlistentry>
      <term><option>onlymacro</option></term>
      <listitem><para>Instructs the preprocessor to only perform the macro-processing step, and stop just after. Mainly useful for debugging purposes or for using the macro-processor independently of the rest of Dynare toolbox.</para></listitem>
    </varlistentry>
    <varlistentry>
      <term><option>nolinemacro</option></term>
      <listitem><para>Instructs the macro-preprocessor to omit line numbering information in the intermediary <filename class="extension">.mod</filename> file created after the maco-processing step. Useful in conjunction with <option>savemacro</option> when one wants that to reuse the intermediary <filename class="extension">.mod</filename> file, without having it cluttered by line numbering directives.</para></listitem>
    </varlistentry>
    <varlistentry>
      <term><option>warn_uninit</option></term>
      <listitem><para>Display a warning for each variable or parameter which is not initialized. Initialization should be done through <xref linkend="param_init"/> or <xref linkend="load_params_and_steady_state"/> for parameters, or through <xref linkend="initval"/>, <xref linkend="endval"/> or <xref linkend="load_params_and_steady_state"/> for endogenous and exogenous.</para></listitem>
    </varlistentry>
    <varlistentry>
      <term><option>cygwin</option></term>
      <listitem><para>Tells Dynare that your <trademark class="registered">MATLAB</trademark> is configured for compiling MEX files with Cygwin (see <xref linkend="software-requirements"/>). This option is only available under Windows, and is used in conjunction with <xref linkend="use_dll"/>.</para></listitem>
    </varlistentry>
    <varlistentry>
      <term><option>msvc</option></term>
      <listitem><para>Tells Dynare that your <trademark class="registered">MATLAB</trademark> is configured for compiling MEX files with Microsoft Visual C++ (see <xref linkend="software-requirements"/>). This option is only available under Windows, and is used in conjunction with <xref linkend="use_dll"/>.</para></listitem>
    </varlistentry>
  </variablelist>

</refsect1>

<refsect1><title>Output</title>
<para>
Depending on the computing tasks requested in the <filename class="extension">.mod</filename> file, executing command <command>dynare</command> will leave in the workspace variables containing results available for further processing. More details are given under the relevant computing tasks.
</para>

<para>
The <varname>M_</varname>, <varname>oo_</varname> and <varname>options_</varname> structures are also saved in a file called <replaceable>FILENAME</replaceable><filename>_results.mat</filename>.
</para>
</refsect1>

<refsect1><title>Examples</title>
<informalexample>
<programlisting>
dynare ramst
dynare ramst.mod savemacro
</programlisting>
</informalexample>
</refsect1>
</refentry>
</chapter>

<chapter id="modfile"><title>The Model file</title>
<para>
Dynare commands are either single instructions or a block of instructions. Each single instruction and each element of a block is terminated by a semicolon (<literal>;</literal>). Blocks of instructions are terminated by <command>end</command><literal>;</literal>.
</para>

<para>
Most Dynare commands have arguments and several accept options, indicated in parentheses after the command keyword.
</para>

<para id="conventions" xreflabel="Conventions">
In the description of Dynare commands, the following conventions are observed:
<itemizedlist>
<listitem><para>optional arguments or options are indicated between square brackets <literal>[]</literal></para></listitem>
<listitem><para>repreated arguments are indicated by ellipses <literal>...</literal></para></listitem>
<listitem><para>mutually exclusive arguments are separated by vertical bars <literal>|</literal></para></listitem>
<listitem><para><replaceable>INTEGER</replaceable> indicates an integer number</para></listitem>
<listitem><para><replaceable>DOUBLE</replaceable> indicates a double precision number. The following syntaxes are valid: <literal>1.1e3</literal>, <literal>1.1E3</literal>, <literal>1.1d3</literal>, <literal>1.1D3</literal></para></listitem>
<listitem><para><replaceable>EXPRESSION</replaceable> indicates a mathematical expression valid outside the model description (see <xref linkend="expressions"/>)</para></listitem>
<listitem><para><replaceable>MODEL_EXPRESSION</replaceable> indicates a mathematical expression valid in the model description (see <xref linkend="expressions"/> and <xref linkend="model"/>)</para></listitem>
<listitem><para><replaceable>VARIABLE_NAME</replaceable> indicates a variable name starting with an alphabetical character and can't contain <literal>()+-*/^=!;:@#.</literal> or accentuated characters</para></listitem>
<listitem><para><replaceable>PARAMETER_NAME</replaceable> indicates a parameter name starting with an alphabetical character and can't contain <literal>()+-*/^=!;:@#.</literal> or accentuated characters</para></listitem>
<listitem><para><replaceable>LATEX_NAME</replaceable> indicates a valid LaTeX expression in math mode (not including the dollar signs)</para></listitem>
<listitem><para><replaceable>FILENAME</replaceable> indicates a filename valid in the underlying operating system; it is necessary to put it between double quotes when specifying the extension or if the filename contains a non-alphanumeric character</para></listitem>
</itemizedlist>
</para>

<sect1 id="vardecls"><title>Variable declarations</title>

<para>Declarations of variables and parameters are made with the following commands:</para>
<itemizedlist>
<listitem><para><xref linkend='var'/></para></listitem>
<listitem><para><xref linkend='varexo'/></para></listitem>
<listitem><para><xref linkend='varexo_det'/></para></listitem>
<listitem><para><xref linkend='parameters'/></para></listitem>
<listitem><para><xref linkend='change_type'/></para></listitem>
<listitem><para><xref linkend='predetermined_variables'/></para></listitem>
</itemizedlist>

<refentry id="var">
  <refmeta>
    <refentrytitle>var</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>var</refname>
    <refpurpose>declares endogenous variables</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>var</command>
      <arg choice="plain">
	      <replaceable>VARIABLE_NAME</replaceable>
	      <arg>$<replaceable>LATEX_NAME</replaceable>$</arg>
      </arg>
      <arg rep="repeat"><arg>,</arg>
	      <replaceable>VARIABLE_NAME</replaceable>
	      <arg>$<replaceable>LATEX_NAME</replaceable>$</arg>
      </arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
This required command declares the endogenous variables in the model. See <xref linkend="conventions"/> for the syntax of <replaceable>VARIABLE_NAME</replaceable>. Optionally it is possible to give a LaTeX name to the variable.
</para>
<para><command>var</command> commands can appear several times in the file and Dynare will concatenate them.</para>
</refsect1>

<refsect1><title>Example</title>
<informalexample>
<programlisting>
var c gnp q1 q2;
</programlisting>
</informalexample>
</refsect1>
</refentry>

<refentry id="varexo">
  <refmeta>
    <refentrytitle>varexo</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>varexo</refname>
    <refpurpose>declares exogenous variables</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>varexo</command>
      <arg choice="plain">
	      <replaceable>VARIABLE_NAME</replaceable>
	      <arg>$<replaceable>LATEX_NAME</replaceable>$</arg>
      </arg>
      <arg rep="repeat"><arg>,</arg>
	      <replaceable>VARIABLE_NAME</replaceable>
	      <arg>$<replaceable>LATEX_NAME</replaceable>$</arg>
      </arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
This optional command declares the exogenous variables in the model. See <xref linkend="conventions"/> for the syntax of <replaceable>VARIABLE_NAME</replaceable>. Optionally it is possible to give a LaTeX name to the variable.
</para>
<para>
Exogenous variables are required if the user wants to be able to apply shocks to her model. 
</para>
<para><command>varexo</command> commands can appear several times in the file and Dynare will concatenate them.</para>
</refsect1>

<refsect1><title>Example</title>
<informalexample>
<programlisting>
varexo m gov;
</programlisting>
</informalexample>
</refsect1>
</refentry>

<refentry id="varexo_det">
  <refmeta>
    <refentrytitle>varexo_det</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>varexo_det</refname>
    <refpurpose>declares exogenous deterministic variables in a stochastic model</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>varexo_det</command>
      <arg choice="plain">
	      <replaceable>VARIABLE_NAME</replaceable>
	      <arg>$<replaceable>LATEX_NAME</replaceable>$</arg>
      </arg>
      <arg rep="repeat"><arg>,</arg>
	      <replaceable>VARIABLE_NAME</replaceable>
	      <arg>$<replaceable>LATEX_NAME</replaceable>$</arg>
      </arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
This optional command declares exogenous deterministic variables in a stochastic model. See <xref linkend="conventions"/> for the syntax of <replaceable>VARIABLE_NAME</replaceable>. Optionally it is possible to give a LaTeX name to the variable.
</para>
<para>It is possible to mix deterministic and stochastic shocks to build models where agents know from the start of the simulation about future exogenous changes. In that case <xref linkend="stoch_simul"/> will compute the rational expectation solution adding future information to the state space (nothing is shown in the output of <xref linkend="stoch_simul"/>) and <xref linkend="forecast"/> will compute a simulation conditional on initial conditions and future information.
</para>
<para><command>varexo_det</command> commands can appear several times in the file and Dynare will concatenate them.</para>
</refsect1>

<refsect1><title>Example</title>
<informalexample>
<programlisting>
varexo m gov;
varexo_det tau;
</programlisting>
</informalexample>
</refsect1>
</refentry>

<refentry id="parameters">
  <refmeta>
    <refentrytitle>parameters</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>parameters</refname>
    <refpurpose>declares parameters</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>parameters</command>
      <arg choice="plain">
	      <replaceable>PARAMETER_NAME</replaceable>
	      <arg>$<replaceable>LATEX_NAME</replaceable>$</arg>
      </arg>
      <arg rep="repeat"><arg>,</arg>
	      <replaceable>PARAMETER_NAME</replaceable>
	      <arg>$<replaceable>LATEX_NAME</replaceable>$</arg>
      </arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
This command declares parameters used in the model, in variable initialization or in shocks declarations. See <xref linkend="conventions"/> for the syntax of <replaceable>PARAMETER_NAME</replaceable>. Optionally it is possible to give a LaTeX name to the parameter.
</para>
<para>The parameters must subsequently be assigned values, see <xref linkend="param_init"/>.
</para>
<para><command>parameters</command> commands can appear several times in the file and Dynare will concatenate them.</para>
</refsect1>

<refsect1><title>Example</title>
<informalexample>
<programlisting>
parameters alpha, bet;
</programlisting>
</informalexample>
</refsect1>
</refentry>

<refentry id="change_type">
  <refmeta>
    <refentrytitle>change_type</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>change_type</refname>
    <refpurpose>modify the type of declared variables/parameters</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>change_type</command>
      <arg choice="plain">(</arg>
      <group choice="plain">
	<arg choice="plain">var</arg>
	<arg choice="plain">varexo</arg>
	<arg choice="plain">varexo_det</arg>
	<arg choice="plain">parameters</arg>
      </group>
      <arg choice="plain">)</arg>
      <group choice="plain">
	<arg choice="plain"><replaceable>VARIABLE_NAME</replaceable></arg>
	<arg choice="plain"><replaceable>PARAMETER_NAME</replaceable></arg>
      </group>
      <arg rep="repeat">
	<arg>,</arg>
	<group choice="plain">
	  <arg choice="plain"><replaceable>VARIABLE_NAME</replaceable></arg>
	  <arg choice="plain"><replaceable>PARAMETER_NAME</replaceable></arg>
	</group>
      </arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
Changes the types of the specified variables/parameters to another type: endogenous, exogenous, exogenous deterministic or parameter.
</para>
<para>It is important to understand that this command has a global effect on the <filename class="extension">.mod</filename> file: the type change is effective after, but also before, the <command>change_type</command> command. This command is typically used when flipping some variables for steady state calibration: typically a separate model file is used for calibration, which includes the list of variable declarations with the macro-processor, and flips some variable.
</para>
</refsect1>

<refsect1><title>Example</title>
<informalexample>
<programlisting>
var y, w;
parameters alpha, bet;
...
change_type(var) alpha, bet;
change_type(parameters) y, w;
</programlisting>
<para>Here, in the whole model file, <varname>alpha</varname> and <varname>beta</varname> will be endogenous and <varname>y</varname> and <varname>w</varname> will be parameters.</para>
</informalexample>
</refsect1>
</refentry>

<refentry id="predetermined_variables">
  <refmeta>
    <refentrytitle>predetermined_variables</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>predetermined_variables</refname>
    <refpurpose>declare some endogenous variables as predetermined</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>predetermined_variables</command>
      <arg choice="plain"><replaceable>VARIABLE_NAME</replaceable></arg>
      <arg rep="repeat"><replaceable>VARIABLE_NAME</replaceable></arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
In Dynare, the default convention is that the timing of a variable reflects when this variable is decided. The typical example is for capital stock: since the capital stock used at current period is actually decided at the previous period, then the capital stock entering the production function is <literal>k(-1)</literal>, and the law of motion of capital must be written:
<programlisting>
k = i + (1-delta)*k(-1)
</programlisting>
</para>

<para>Put another way, for stock variables, the default in Dynare is to use a
“stock at the end of the period” concept, instead of a “stock at the beginning of the period”
convention.</para>


<para>The <command>predetermined_variables</command> is used to change that convention. The endogenous variables declared as predetermined variables are supposed to be decided one period ahead of all other endogenous variables. For stock variables, they are supposed
to follow a “stock at the beginning of the period”
convention.</para>

</refsect1>

<refsect1><title>Example</title>
<informalexample>

<para>The following two program snippets are strictly equivalent.</para>

<formalpara><title>Using default Dynare timing convention:</title>
<para>
<programlisting>
var y, k, i;
...
model;
y = k(-1)^alpha;
k = i + (1-delta)*k(-1);
...
end;
</programlisting>
</para>
</formalpara>

<formalpara><title>Using the alternative timing convention:</title>
<para>
<programlisting>
var y, k, i;
predetermined_variables k;
...
model;
y = k^alpha;
k(+1) = i + (1-delta)*k;
...
end;
</programlisting>
</para>
</formalpara>
</informalexample>
</refsect1>
</refentry>

</sect1>

<sect1 id="expressions"><title>Expressions</title>

  <para>Dynare distinguishes between two types of mathematical expressions: those that are used to describe the model, and those that are used outside the model block (<foreignphrase>e.g.</foreignphrase> for initializing parameters or variables, or as command options). In this manual, those two types of expressions are respectively denoted by <replaceable>MODEL_EXPRESSION</replaceable> and <replaceable>EXPRESSION</replaceable>.</para>

  <para>Unlike <trademark class="registered">MATLAB</trademark> or Octave expressions, Dynare expressions are necessarily scalar ones: they cannot contain matrices or evaluate to matrices<footnote><para>Note that arbitrary <trademark class="registered">MATLAB</trademark> or Octave expressions can be put in a <filename class="extension">.mod</filename> file, but those expressions have to be on separate lines, generally at the end of the file for post-processing purposes. They are not interpreted by Dynare, and are simply passed on unmodified to <trademark class="registered">MATLAB</trademark> or Octave. Those constructions are not addresses in this section.</para></footnote>.</para>

  <para>Expressions can be constructed using integers (<replaceable>INTEGER</replaceable>), floating point numbers (<replaceable>DOUBLE</replaceable>), parameter names (<replaceable>PARAMETER_NAME</replaceable>), variable names (<replaceable>VARIABLE_NAME</replaceable>), operators and functions.</para>

  <sect2>
    <title>Parameters and variables</title>

    <para>Parameters and variables can be introduced in expressions by simply typing their names. The semantics of parameters and variables is quite different whether they are used inside or outside the model block.</para>

    <sect3>
      <title>Inside the model</title>

      <para>Parameters used inside the model refer to the value given through <link linkend="param_init">parameter initialization</link> or <xref linkend="homotopy_setup"/> when doing a simulation, or are the estimated variables when doing an estimation.</para>

      <para>Variables used in a <replaceable>MODEL_EXPRESSION</replaceable> denote <emphasis>current period</emphasis> values when neither a lead or a lag is given. A lead or a lag can be given by enclosing an integer between parenthesis just after the variable name: a positive integer means a lead, a negative one means a lag. Leads or lags of more than one period are allowed. For example, if <literal>c</literal> is an endogenous variable, then <literal>c(+1)</literal> is the variable one period ahead, and <literal>c(-2)</literal> is the variable two periods before.</para>

      <para>When specifying the leads and lags of endogenous variables, it is important to respect the following convention: in Dynare, the timing of a variable reflects when that variable is decided. A control variable - which by definition is decided in the current period - must have no lead. A predetermined variable - which by definition has been decided in a previous period - must have a lag. A consequence of this is that all stock variables must use the "stock at the end of the period" convention. Please refer to <xref linkend="bib_userguide"/> for more details and concrete examples.</para>

      <para>Leads and lags are primarily used for endogenous variables, but can be used for exogenous variables. They have no effect on parameters and are forbidden for local model variables (see <xref linkend="model"/>).</para>

    </sect3>

    <sect3>
      <title>Outside the model</title>
      <para>When used in an expression outside the model block, a parameter or a variable simply refers to the last value given to that variable. More precisely, for a parameter it refers to the value given in the corresponding <link linkend="param_init">parameter initialization</link>; for an endogenous or exogenous variable, it refers to the value given in the most recent <xref linkend="initval"/> or <xref linkend="endval"/> block.</para>
    </sect3>

  </sect2>

  <sect2><title>Operators</title>
    <para>The following operators are allowed in both <replaceable>MODEL_EXPRESSION</replaceable> and <replaceable>EXPRESSION</replaceable>:
      <itemizedlist>
        <listitem><para>binary arithmetic operators: <literal>+</literal>, <literal>-</literal>, <literal>*</literal>, <literal>/</literal>, <literal>^</literal></para></listitem>
        <listitem><para>unary arithmetic operators: <literal>+</literal>, <literal>-</literal></para></listitem>
        <listitem><para>binary comparison operators (which evaluate to either <literal>0</literal> or <literal>1</literal>): <literal>&lt;</literal>, <literal>&gt;</literal>, <literal>&lt;=</literal>, <literal>&gt;=</literal>, <literal>==</literal>, <literal>!=</literal></para></listitem>
      </itemizedlist>
    </para>
    <para>The following operators are allowed in <replaceable>MODEL_EXPRESSION</replaceable>:
    <itemizedlist>
      <listitem><para>steady state operator: <literal>STEADY_STATE(</literal><replaceable>MODEL_EXPRESSION</replaceable><literal>)</literal>. This operator is used to take the value of the enclosed expression at the steady state. A typical usage is in the Taylor rule, where you may want to use the value of GDP at steady state to compute the output gap.</para></listitem>
      <listitem id="expectation_operator"><para>expectation operator: <literal>EXPECTATION(</literal><replaceable>INTEGER</replaceable><literal>)(</literal><replaceable>MODEL_EXPRESSION</replaceable><literal>)</literal>. This operator is used to take the expectation of some expression using a different information set than the information available at current period. For example, <literal>EXPECTATION(-1)(x(+1))</literal> is equal to the expected value of variable <literal>x</literal> at next period, using the information set available at the previous period. In practice, Dynare solves this by creating an auxiliary variable equal to <literal>AUX = x(+2)</literal>, and by replacing the expectation operator by <literal>AUX(-1)</literal>. Note that a value of <literal>0</literal> for the time shift component is reserved for partial information models (not yet fully implemented).</para></listitem>
    </itemizedlist>
    </para>
  </sect2>

  <sect2><title>Functions</title>
    <para>The following standard functions are allowed in both <replaceable>MODEL_EXPRESSION</replaceable> and <replaceable>EXPRESSION</replaceable>:
      <itemizedlist>
        <listitem><para>exponential: <literal>exp(<replaceable>x</replaceable>)</literal></para></listitem>
        <listitem><para>natural logarithm: <literal>log(<replaceable>x</replaceable>)</literal> (or equivalently <literal>ln(<replaceable>x</replaceable>)</literal>)</para></listitem>
        <listitem><para>base 10 logarithm: <literal>log10(<replaceable>x</replaceable>)</literal></para></listitem>
        <listitem><para>square root: <literal>sqrt(<replaceable>x</replaceable>)</literal></para></listitem>
        <listitem><para>trigonometric functions: <literal>sin(<replaceable>x</replaceable>)</literal>, <literal>cos(<replaceable>x</replaceable>)</literal>, <literal>tan(<replaceable>x</replaceable>)</literal>, <literal>asin(<replaceable>x</replaceable>)</literal>, <literal>acos(<replaceable>x</replaceable>)</literal>, <literal>atan(<replaceable>x</replaceable>)</literal></para></listitem>
        <listitem><para>maximum and minimum: <literal>max(<replaceable>a</replaceable>, <replaceable>b</replaceable>)</literal>, <literal>min(<replaceable>a</replaceable>, <replaceable>b</replaceable>)</literal></para></listitem>
        <listitem><para>gaussian cumulative distribution function: <literal>normcdf(<replaceable>x</replaceable>, <replaceable>&mu;</replaceable>, <replaceable>&sigma;</replaceable>)</literal> (note that <literal>normcdf(<replaceable>x</replaceable>)</literal> is equivalent to <literal>normcdf(<replaceable>x</replaceable>, 0, 1)</literal>)</para></listitem>
      </itemizedlist>
    </para>
    <para>In a <replaceable>MODEL_EXPRESSION</replaceable>, no other function is allowed.<footnote><para>This is due to the fact that the Dynare preprocessor performs a symbolical derivation of all model equations, and therefore needs to know the analytical derivatives of all the equations in the model equations. In the future, we should add support for other usual functions, and implement an interface to let the user define custom functions, for which he would provide the analytical derivatives.</para></footnote></para>
    <para>In an <replaceable>EXPRESSION</replaceable>, it is possible to use any arbitrary <trademark class="registered">MATLAB</trademark> or Octave function, provided that this function has scalar arguments and return value.</para>
</sect2>

</sect1>

<sect1 id="param_init"><title>Parameter initialization</title>

<para>When using Dynare for computing simulations, it is necessary to calibrate the parameters of the model. This is done through parameter initialization.</para>

<formalpara><title>Syntax</title>
<para>
  <programlisting>
  <replaceable>PARAMETER_NAME</replaceable> = <replaceable>EXPRESSION</replaceable> ;
  </programlisting>
</para>
</formalpara>

<formalpara><title>Example</title>

<para>
<informalexample>
<programlisting>
parameters alpha, bet;

beta = 0.99;
alpha = 0.36;
A = 1-alpha*beta;
</programlisting>
</informalexample>
</para>
</formalpara>

</sect1>

<sect1><title>Model declaration</title>

<para>The model is declared inside a <xref linkend="model"/> block.</para>

<para>Note that it is possible to output the list of model equations to a LaTeX file, using the <xref linkend="write_latex_dynamic_model"/> command, or the <xref linkend="write_latex_static_model"/> (for the steady state model).</para>

<refentry id="model">
  <refmeta>
    <refentrytitle>model</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>model</refname>
    <refpurpose>declares the model equations</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>model</command>
      <arg>(<replaceable>OPTION</replaceable><arg rep="repeat">, <replaceable>OPTION</replaceable></arg>)</arg>
      <arg choice="plain">;</arg>
      <sbr/>
      <arg choice="plain" rep="repeat">
        <group>
          <arg choice="plain"><replaceable>MODEL_EXPRESSION</replaceable> = <replaceable>MODEL_EXPRESSION</replaceable> ;</arg>
          <arg choice="plain"><replaceable>MODEL_EXPRESSION</replaceable> ;</arg>
          <arg choice="plain"># <replaceable>VARIABLE_NAME</replaceable> = <replaceable>MODEL_EXPRESSION</replaceable> ;</arg>
        </group>
      </arg><sbr/>
      <command>end</command><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
The equations of the model are written in a block delimited by <command>model</command> and <command>end</command> keywords.
</para>
<para>
There must be as many equations as there are endogenous variables in the model, except when computing the unconstrained optimal policy with <xref linkend="ramsey_policy"/>.</para>

<para>The syntax of equations must follow the conventions for <replaceable>MODEL_EXPRESSION</replaceable> as described in <xref linkend="expressions"/>. Each equation must be terminated by a semicolon (<literal>;</literal>).
</para>
<para>
When the equations are written in homogenous form, it is possible to omit the <literal>=0</literal> part and write only the left hand side of the equation.
</para>
<para>
Inside the model block, Dynare allows the creation of <emphasis>model-local variables</emphasis>, which constitute a simple way to share a common expression between several equations. The syntax consists of a pound sign (<literal>#</literal>) followed by the name of the new model local variable (which must <emphasis>not</emphasis> be declared as in <xref linkend="vardecls"/>), an equal sign, and the expression for which this new variable will stand. Later on, every time this variable appears in the model, Dynare will substitute it by the expression assigned to the variable. Note that the scope of this variable is restricted to the model block; it cannot be used outside.
</para>
</refsect1>

<refsect1><title>Options</title>
  <variablelist>
    <varlistentry>
      <term><option>linear</option></term>
      <listitem><para>Declares the model as being linear. It spares oneself from having to declare initial values for computing the steady state, and it sets automatically <option>order</option><literal>=1</literal> in <xref linkend="stoch_simul" />.</para></listitem>
    </varlistentry>
    <varlistentry id="use_dll">
      <term><option>use_dll</option></term>
      <listitem><para>Instructs the preprocessor to create dynamic loadable libraries (DLL) containing the model equations and derivatives, instead of writing those in <filename class="extension">M</filename>-files. You need a working compilation environment, <foreignphrase>i.e.</foreignphrase> a working <literal>mex</literal> command (see <xref linkend="software-requirements"/> for more details). Using this option can result in faster simulations or estimations, at the expense of some initial compilation time.<footnote><para>In particular, for big models, the compilation step can be very time-consuming, and use of this option may be counter-productive in those cases.</para></footnote></para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>

<refsect1><title>Examples</title>
<refsect2><title>Example 1: elementary RBC model</title>
<informalexample>
<programlisting>
var c k;
varexo x;
parameters aa alph bet delt gam;

model;
c =  - k + aa*x*k(-1)^alph + (1-delt)*k(-1);
c^(-gam) = (aa*alph*x(+1)*k^(alph-1) + 1 - delt)*c(+1)^(-gam)/(1+bet);
end;
</programlisting>
</informalexample>
</refsect2>

<refsect2><title>Example 2: use of model local variables</title>

<informalexample>
<para>The following program:
<programlisting>
model;
# gamma = 1 - 1/sigma;
u1 = c1^gamma/gamma;
u2 = c2^gamma/gamma;
end;
</programlisting>

...is formally equivalent to:
<programlisting>
model;
u1 = c1^(1-1/sigma)/(1-1/sigma);
u2 = c2^(1-1/sigma)/(1-1/sigma);
end;
</programlisting>
</para>
</informalexample>
</refsect2>

<refsect2><title>Example 3: a linear model</title>
<informalexample>
<programlisting>
model(linear);
x = a*x(-1)+b*y(+1)+e_x;
y = d*y(-1)+e_y;
end;
</programlisting>
</informalexample>
</refsect2>
</refsect1>
</refentry>

<refentry id="write_latex_dynamic_model">
  <refmeta>
    <refentrytitle>write_latex_dynamic_model</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>write_latex_dynamic_model</refname>
    <refpurpose>create a LaTeX file containing the (dynamic) model</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>write_latex_dynamic_model</command><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>If your <filename class="extension">.mod</filename> file is <filename><replaceable>FILENAME</replaceable>.mod</filename>, then Dynare will create a file called <filename><replaceable>FILENAME</replaceable>_dynamic.tex</filename>, containing the list of all the dynamic model equations. 
</para>
<para>If LaTeX names were given for variables and parameters (see <xref linkend="var"/>, <xref linkend="varexo"/>, <xref linkend="varexo_det"/>, <xref linkend="parameters"/>), then those will be used; otherwise, the plain text names will be used.</para>
<para>Time subscripts (<literal>t</literal>, <literal>t+1</literal>, <literal>t-1</literal>, ...) will be appended to the variable names, as LaTeX subscripts.</para>

<para>
Note that the model written in the TeX file will differ from the model declared by the user in the following dimensions:
<itemizedlist>
<listitem><para>the timing convention of <xref linkend="predetermined_variables"/> will have been changed to the default Dynare timing convention; in other words, variables declared as predetermined will be lagged on period back,</para></listitem>
<listitem><para>the <link linkend="expectation_operator">expectation operators</link> will have been removed, replaced by auxiliary variables and new equations as explained in the documentation of the operator,</para></listitem>
<listitem><para>for stochastic models, variables with leads or lags greater or equal than two will have been removed, replaced by new auxiliary variables and equations.</para></listitem>
</itemizedlist>
</para>

</refsect1>
</refentry>

<refentry id="write_latex_static_model">
  <refmeta>
    <refentrytitle>write_latex_static_model</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>write_latex_static_model</refname>
    <refpurpose>create a LaTeX file containing the (static) model</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>write_latex_static_model</command><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>If your <filename class="extension">.mod</filename> file is <filename><replaceable>FILENAME</replaceable>.mod</filename>, then Dynare will create a file called <filename><replaceable>FILENAME</replaceable>_static.tex</filename>, containing the list of all the equations of the steady state model.
</para>
<para>If LaTeX names were given for variables and parameters (see <xref linkend="var"/>, <xref linkend="varexo"/>, <xref linkend="varexo_det"/>, <xref linkend="parameters"/>), then those will be used; otherwise, the plain text names will be used.</para>
<para>
Note that the model written in the TeX file will differ from the model declared by the user in the some dimensions, see <xref linkend="write_latex_dynamic_model"/>.
</para>
</refsect1>
</refentry>

</sect1>

<sect1><title>Initial and terminal conditions</title>

<para>For most simulation exercises, it is necessary to provide initial (and possibly terminal) conditions. It is also necessary to provide initial guess values for non-linear solvers. The following statements are used for those purposes:</para>
<itemizedlist>
  <listitem><para><xref linkend='initval'/></para></listitem>
  <listitem><para><xref linkend='endval'/></para></listitem>
  <listitem><para><xref linkend='histval'/></para></listitem>
  <listitem><para><xref linkend='resid'/></para></listitem>
  <listitem><para><xref linkend='initval_file'/></para></listitem>
</itemizedlist>

<para>In many contexts (determistic or stochastic), it is necessary to compute the steady state of a non-linear model: <xref linkend='initval'/> then specifies numerical initial values for the non-linear solver. The command <xref linkend='resid'/> can be used to compute the equation residuals for the given initial values.
</para>
<para>
Used in perfect foresight mode, the types of forward-loking models for which Dynare was designed require both initial and terminal conditions. Most often these initial and terminal conditions are static equilibria, but not necessarily. 
</para>
<para>
One typical application is to consider an economy at the equilibrium, trigger a shock in first period, and study the trajectory of return at the initial equilbrium. To do that, one needs <xref linkend='initval'/> and <xref linkend='shocks'/> (see <xref linkend="sec_shocks"/>.
</para>
<para>
Another one is to study, how an economy, starting from arbitrary initial conditions converges toward equilibrium. To do that, one needs <xref linkend='initval'/> and <xref linkend='endval'/>; 
</para>
<para>
For models with lags on more than one period, the command <xref linkend='histval'/> permits to specify different historical initial values for periods before the beginning of the simulation.
</para>

<refentry id="initval">
  <refmeta>
    <refentrytitle>initval</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>initval</refname>
    <refpurpose>specifies numerical starting values for finding the steady state and/or initial values for simulations</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>initval</command><arg choice="plain">;</arg><sbr/>
      <arg rep="repeat" choice="plain">
	      <replaceable>VARIABLE_NAME</replaceable> = <replaceable>EXPRESSION</replaceable> ;
      </arg><sbr/>
      <command>end</command><arg choice="plain">;</arg><sbr/>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>The <command>initval</command> block serves two purposes: declaring the initial (and possibly terminal) conditions in a simulation exercise, and providing guess values for non-linear solvers.</para>

<refsect2><title>In a deterministic (<foreignphrase>i.e.</foreignphrase> perfect foresight) model</title>

<para>First, it provides the initial conditions for all the endogenous and exogenous variables at all the periods preceeding the first simulation period (unless some of these initial values are modified by <xref linkend="histval"/>).</para>

<para>Second, in the absence of an <xref linkend="endval"/> block, it sets the terminal conditions for all the periods succeeding the last simulation period.</para>

<para>Third, in the absence of an <xref linkend="endval"/> block, it provides initial guess values at all simulation dates for the non-linear solver implemented in <xref linkend="simul"/>.</para>

<para>For this last reason, it necessary to provide values for all the endogenous variables in an <command>initval</command> block (even though, theoretically, initial conditions are only necessary for lagged variables). If some exogenous variables are not mentionned in the <command>initval</command> block, a zero value is assumed.</para>

<para>Note that if the <command>initval</command> block is immediately followed by a <xref linkend="steady"/> command, its semantics is changed. The <xref linkend="steady"/> command will compute the steady state of the model for all the endogenous variables, assuming that exogenous variables are kept constant to the value declared in the <command>initval</command> block, and using the values declared for the endogenous as initial guess values for the non-linear solver. An <command>initval</command> block followed by <xref linkend="steady"/> is formally equivalent to an <command>initval</command> block with the same values for the exogenous, and with the associated steady state values for the endogenous.</para>

</refsect2>

<refsect2><title>In a stochastic model</title>

<para>The main purpose of <command>initval</command> is to provide initial guess values for the non-linear solver in the steady state computation. Note that if the <command>initval</command> block is not followed by <xref linkend="steady"/>, the steady state computation will still be triggered by subsequent commands (<xref linkend="stoch_simul"/>, <xref linkend="estimation"/>...).</para>

<para>It is not necessary to declare <literal>0</literal> as initial value for exogenous stochastic variables, since it is the only possible value.</para>

<para>This steady state will be used as the initial condition at all the periods preceeding the first simulation period for the two possible types of simulations in stochastic mode:</para>
<itemizedlist>
  <listitem><para>in <xref linkend="stoch_simul"/>, if the <option>periods</option> options is specified</para></listitem>
  <listitem><para>in <xref linkend="forecast"/> (in this case, note that it is still possible to modify some of these initial values with <xref linkend="histval"/>)</para></listitem>
</itemizedlist>

</refsect2>
</refsect1>

<refsect1><title>Example</title>
<informalexample>
<programlisting>
initval;
c = 1.2;
k = 12;
x = 1;
end;

steady;
</programlisting>
</informalexample>
</refsect1>
</refentry>

<refentry id="endval">
  <refmeta>
    <refentrytitle>endval</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>endval</refname>
    <refpurpose>specifies terminal values for deterministic simulations</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>endval</command><arg choice="plain">;</arg><sbr/>
      <arg rep="repeat" choice="plain">
	      <replaceable>VARIABLE_NAME</replaceable> = <replaceable>EXPRESSION</replaceable> ;
      </arg><sbr/>
      <command>end</command><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>

<para>The <command>endval</command> block makes only sense in a determistic model, and serves two purposes.</para>

<para>First, it sets the terminal conditions for all the periods succeeding the last simulation period.</para>

<para>Second, it provides initial guess values at all the simulation dates for the non-linear solver implemented in <xref linkend="simul"/>.</para>

<para>For this last reason, it necessary to provide values for all the endogenous variables in an <command>endval</command> block (even though, theoretically, initial conditions are only necessary for forward variables). If some exogenous variables are not mentionned in the <command>endval</command> block, a zero value is assumed.</para>

<para>Note that if the <command>endval</command> block is immediately followed by a <xref linkend="steady"/> command, its semantics is changed. The <xref linkend="steady"/> command will compute the steady state of the model for all the endogenous variables, assuming that exogenous variables are kept constant to the value declared in the <command>endval</command> block, and using the values declared for the endogenous as initial guess values for the non-linear solver. An <command>endval</command> block followed by <xref linkend="steady"/> is formally equivalent to an <command>endval</command> block with the same values for the exogenous, and with the associated steady state values for the endogenous.</para>
</refsect1>

<refsect1><title>Example</title>
<informalexample>
<programlisting>
var c k;
varexo x;
...
initval;
c = 1.2;
k = 12;
x = 1;
end;

steady;

endval;
c = 2;
k = 20;
x = 2;
end;

steady;
</programlisting>
</informalexample>
<para>
The initial equilibrium is computed by <xref linkend='steady'/> for <literal>x=1</literal>, and the terminal one, for <literal>x=2</literal>.
</para>
</refsect1>
</refentry>

<refentry id="histval">
  <refmeta>
    <refentrytitle>histval</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>histval</refname>
    <refpurpose>specifies historical values before the start of a simulation</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>histval</command><arg choice="plain">;</arg><sbr/>
      <arg rep="repeat" choice="plain">
	      <replaceable>VARIABLE_NAME</replaceable>(<replaceable>INTEGER</replaceable>) = <replaceable>EXPRESSION</replaceable> ;
      </arg><sbr/>
      <command>end</command><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
<replaceable>EXPRESSION</replaceable> is any valid expression returning a numerical value and can contain already initialized variable names.
</para>
<para>
In models with lags on more than one period, the optional <command>histval;</command> ... <command>end;</command> block permits to specify different historical initial values for different periods.
</para>
<para>
By convention in Dynare, period 1 is the first period of the simulation. Going backward in time, the first period before the start of the simulation is period 0, then period -1, and so on.
</para>
<para>
If your lagged variables are linked by identities, be careful to satisfy these identities when you set historical initial values.
</para>
</refsect1>

<refsect1><title>Example</title>
<informalexample>
<programlisting>
var x y;
varexo e;

model;
x = y(-1)^alpha*y(-2)^(1-alpha)+e;
...
end;

initval;
x = 1;
y = 1;
e = 0.5;
end;

steady;

histval;
y(0) = 1.1;
y(-1) = 0.9;
end;
</programlisting>
</informalexample>
</refsect1>

</refentry>

<refentry id="resid">
  <refmeta>
    <refentrytitle>resid</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>resid</refname>
    <refpurpose>display the residual of the static equations</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>resid</command><arg choice="plain">;</arg><sbr/>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>This command will display the residuals of the static equations of the model, using the values given for the endogenous in the last <xref linkend="initval"/> or <xref linkend="endval"/> block (or the steady state file if you provided one).</para>
</refsect1>

</refentry>


<refentry id="initval_file">
  <refmeta>
    <refentrytitle>initval_file</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>initval_file</refname>
    <refpurpose>use an external to specify a path for exogenous and endogenous variables in a deterministic simulation</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>initval_file</command><arg choice="plain">(<option>filename</option> = <replaceable>FILENAME</replaceable>)</arg><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1><title>Description</title>
  <para>In a deterministic setup, this command is used to specify a path for all endogenous and exogenous variables. The length of these paths must be equal to the number of simulation periods, plus the number of leads and the number of lags of the model (for example, with 50 simulation periods, in a model with 2 lags and 1 lead, the paths must have a length of 53). Note that these paths cover two different things:
  <itemizedlist>
    <listitem><para>the constraints of the problem, which are given by the path for exogenous and the initial and terminal values for endogenous</para></listitem>
    <listitem><para>the initial guess for the non-linear solver, which is given by the path for endogenous variables for the simulation periods (excluding initial and terminal conditions)</para></listitem>
  </itemizedlist>
  </para>
  <para>The command accepts three file formats:
  <itemizedlist>
    <listitem><para>M-file (extension <filename class="extension">.m</filename>): for each endogenous and exogenous variable, the file must contain a row vector of the same name</para></listitem>
    <listitem><para>MAT-file (extension <filename class="extension">.mat</filename>): same as for M-files</para></listitem>
    <listitem><para>Excel file (extension <filename class="extension">.xls</filename>): for each endogenous and exogenous, the file must contain a column of the same name</para></listitem>
  </itemizedlist>
  </para>
  <warning><para>The extension must be omitted in the command argument. Dynare will automatically figure out the extension and select the appropriate file type.</para></warning>
  </refsect1>

</refentry>

</sect1>

<sect1 id="sec_shocks"><title>Shocks on exogenous variables</title>
<para>
In a deterministic context, when one wants to study the transition of one equilibrium position to another, it is equivalent to analyze the consequences of a permanent shock and this in done in Dynare through the proper use of <xref linkend='initval'/> and <xref linkend='endval'/>.
</para>
<para>
Another typical experiment is to study the effects of a temporary shock after which the system goes back to the original equilibrium (if the model is stable ...). A temporary shock is a temporary change of value of one or several exogenous variables in the model. Temporary shocks are specified with the command <xref linkend='shocks'/>.
</para>
<para>
In a stochastic framework, the exogenous variables take random values in each period. In Dynare, these random values follow a normal distribution with zero mean, but it belongs to the user to specify the variability of these shocks. The non-zero elements of the matrix of variance-covariance of the shocks can be entered with the <xref linkend='shocks'/> command. Or, the entire matrix can be direclty entered with <xref linkend='Sigma_e'/> (this use is however deprecated).
</para>
<para>
If the variance of an exogenous variable is set to zero, this variable will appear in the report on policy and transition functions, but isn't used in the computation of moments and of Impulse Response Functions. Setting a variance to zero is an easy way of removing an exogenous shock.
</para>
<itemizedlist>
<listitem><para><xref linkend='shocks'/></para></listitem>
<listitem><para><xref linkend='mshocks'/></para></listitem>
<listitem><para><xref linkend='Sigma_e'/> (deprecated)</para></listitem>
</itemizedlist>

<refentry id="shocks">
  <refmeta>
    <refentrytitle>shocks</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>shocks</refname>
    <refpurpose>specifies shocks on deterministic or stochastic exogenous variables</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>shocks</command><arg choice="plain">;</arg><sbr/>
      <arg rep="repeat">
        <group>
	        <arg choice="plain">
	          <synopfragmentref linkend="det_shock">DETERMINISTIC SHOCK STATEMENT</synopfragmentref>
	        </arg>
	        <arg choice="plain">
	          <synopfragmentref linkend="sto_shock">STOCHASTIC SHOCK STATEMENT</synopfragmentref>
	        </arg>
        </group>
      </arg><sbr/>
      <command>end</command><arg choice="plain">;</arg>

      <synopfragment id="det_shock">
	      <arg choice="plain">var <replaceable>VARIABLE_NAME</replaceable>;</arg>
	      <arg choice="plain">periods <replaceable>INTEGER</replaceable><arg>:<replaceable>INTEGER</replaceable></arg><arg rep="repeat"><arg>,</arg> <replaceable>INTEGER</replaceable><arg>:<replaceable>INTEGER</replaceable></arg></arg>;</arg>
        <arg choice="plain">values <replaceable>EXPRESSION</replaceable> <arg rep="repeat"><arg>,</arg> <replaceable>EXPRESSION</replaceable></arg>;</arg>
      </synopfragment>

      <synopfragment id="sto_shock">
	      <group choice="plain">
          <arg choice="plain">var <replaceable>VARIABLE_NAME</replaceable>; stderr <replaceable>EXPRESSION</replaceable>;</arg>
	        <arg choice="plain">var <replaceable>VARIABLE_NAME</replaceable> = <replaceable>EXPRESSION</replaceable>;</arg>
          <arg choice="plain">var <replaceable>VARIABLE_NAME</replaceable>, <replaceable>VARIABLE_NAME</replaceable> = <replaceable>EXPRESSION</replaceable>;</arg>
          <arg choice="plain">corr <replaceable>VARIABLE_NAME</replaceable>, <replaceable>VARIABLE_NAME</replaceable> = <replaceable>EXPRESSION</replaceable>;</arg>
        </group>
      </synopfragment>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<refsect2><title>In deterministic context</title>
<para>
For deterministic simulations, the <command>shocks</command> block specifies temporary changes in the value of an exogenous variables. For permanent shocks, use an <xref linkend='endval'/> block.
</para>

<para>When specifying shocks on several periods, the <command>values</command> <replaceable>EXPRESSION</replaceable> must return either a scalar value common to all periods with a shock or a column vector with as many elements as there are periods in the <command>periods</command> statement just before it.
</para>

<refsect3><title>Example</title> 
<informalexample>
<programlisting>
shocks;
var e;
periods 1;
values 0.5;
var u;
periods 4:5;
values 0;
var v;
periods 4 5 6;
values 0;
var u;
periods 4  5   6;
values  1 1.1 0.9;
end;
</programlisting>
</informalexample>
</refsect3>
</refsect2>

<refsect2><title>In stochastic context</title>
<para>
For stochastic simulations, the <command>shocks</command> block specifies the non zero elements of the covariance matrix of the shocks.
</para>

<refsect3><title>Example</title> 
<informalexample>
<programlisting>
shocks;
var e = 0.000081;
var u; stderr 0.009;
corr e, u = 0.8;
var v, w = 2;
end;
</programlisting>
</informalexample>
</refsect3>
<refsect3><title>See also</title>
<para><xref linkend="Sigma_e"/></para>
</refsect3>
</refsect2>

<refsect2><title>Mixing determininistic and stochastic shocks</title>
<para>It is possible to mix deterministic and stochastic shocks to build models where agents know from the start of the simulation about future exogenous changes. In that case <xref linkend="stoch_simul"/> will compute the rational expectation solution adding future information to the state space (nothing is shown in the output of <xref linkend="stoch_simul"/>) and <xref linkend="forecast"/> will compute a simulation conditional on initial  conditions and future information.
</para>

<refsect3><title>Example</title>
<informalexample>
  <programlisting>
varexo_det tau;
varexo e;

...

shocks;
var e; stderr 0.01;
var tau;
periods 1:9;
values -0.15;
end;

stoch_simul(irf=0);

forecast;
  </programlisting>
</informalexample>
</refsect3>
</refsect2>

</refsect1>
</refentry>

<refentry id="mshocks">
  <refmeta>
    <refentrytitle>mshocks</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>mshocks</refname>
    <refpurpose>specifies multiplicative deterministic shocks on exogenous variables</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>mshocks</command><arg choice="plain">;</arg><sbr/>
      <arg rep="repeat">
	      <arg choice="plain">var <replaceable>VARIABLE_NAME</replaceable>;</arg>
	      <arg choice="plain">periods <replaceable>INTEGER</replaceable><arg>:<replaceable>INTEGER</replaceable></arg>
          <arg rep="repeat"><arg>,</arg> <replaceable>INTEGER</replaceable><arg>:<replaceable>INTEGER</replaceable></arg></arg>;</arg>
	      <arg choice="plain">values <replaceable>EXPRESSION</replaceable> <arg rep="repeat"><arg>,</arg> <replaceable>EXPRESSION</replaceable></arg>;</arg>
      </arg><sbr/>
      <command>end</command><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1><title>Description</title>
  <para>The purpose of this command is similar to that of the <xref linkend="shocks"/> for deterministic shocks, except that the numeric values given will be interpreted in a multiplicative way. For example, if a value of <literal>1.05</literal> is given as shock value for some exogenous at some date, it means 5% above its steady state value (as given by the last <xref linkend="initval"/> or <xref linkend="endval"/> block).</para>

  <para>This command is only meaningful in two situations:
  <itemizedlist>
    <listitem><para>on exogenous variables with a non-zero steady state, in a deterministic setup,</para></listitem>
    <listitem><para>on deterministic exogenous variables with a non-zero steady state, in a stochastic setup.</para></listitem>
  </itemizedlist>
  </para>
  </refsect1>
</refentry>

<refentry id="Sigma_e">
  <refmeta>
    <refentrytitle>Sigma_e</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>Sigma_e</refname>
    <refpurpose>specifies directly the covariance matrix of the stochastic shocks</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>Sigma_e</command>
<arg choice="plain">	= [ <replaceable>EXPRESSION</replaceable> <arg rep="repeat"><arg>,</arg> <replaceable>EXPRESSION</replaceable></arg>
      <arg rep="repeat">; <replaceable>EXPRESSION</replaceable> <arg rep="repeat"><arg>,</arg> <replaceable>EXPRESSION</replaceable></arg></arg> ];</arg>
    </cmdsynopsis>
    <warning>
      <para>The matrix elements are actually written between square brackets (<literal>[]</literal>). Here, the initial <literal>[</literal> and final <literal>]</literal> don't have the meaning of <quote>optional element</quote> as elsewhere.</para>
    </warning>
  </refsynopsisdiv>


<refsect1><title>Description</title>

<para>
The matrix of variance-covariance of the shocks can be directly specified as a upper (or lower) triangular matrix. Dynare builds the corresponding symmetrix matrix. Each row of the triangular matrix, except the last one, must be terminated by a semi-colon <literal>;</literal>. For a given element, an arbitrary <replaceable>EXPRESSION</replaceable> is allowed (instead of a simple constant), but in that case you need to enclose the expression in parentheses. <emphasis>The order of the covariances in the matrix is the same as the one used in the <xref linkend="varexo"/> declaration.</emphasis>
</para>
</refsect1>

<refsect1><title>Example</title>
<informalexample>
<programlisting>
varexo u, e;
...
Sigma_e = [ 0.81 (phi*0.9*0.009); 0.000081];
</programlisting>
<para>
where the variance of <varname>u</varname> is 0.81, the variance of <varname>e</varname>, 0.000081, and the correlation between <varname>e</varname> and <varname>u</varname> is <varname>phi</varname>.
</para>
</informalexample>
</refsect1>
</refentry>
</sect1>

<sect1><title>Other general declarations</title>

<itemizedlist>
<listitem><para><xref linkend='dsample'/></para></listitem>
<listitem><para><xref linkend='periods'/> (deprecated)</para></listitem>
</itemizedlist>

<refentry id="dsample">
  <refmeta>
    <refentrytitle>dsample</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>dsample</refname>
    <refpurpose>reduces the number of periods considered in subsequent output commands</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>dsample</command>
      <arg choice="plain"><replaceable>INTEGER</replaceable></arg>
      <arg><replaceable>INTEGER</replaceable></arg><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1><title>Description</title>
  <para>...</para>
  </refsect1>
</refentry>

<refentry id="periods">
  <refmeta>
    <refentrytitle>periods</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>periods</refname>
    <refpurpose>specifies the number of simulation periods</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>periods</command> <arg choice="plain">
      <replaceable>INTEGER</replaceable>;
      </arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
This command is now deprecated (but will still work for older model files). It is not necessary when no simulation is performed and is replaced by an option <option>periods</option> in <xref linkend="simul"/> and <xref linkend="stoch_simul"/>.
</para>
<para>
Sets the number of periods in the simulation. The periods are numbered from <literal>1</literal> to <replaceable>INTEGER</replaceable>. In perfect foresight simulations, it is assumed that all future events are perfectly known at the beginning of period <literal>1</literal>.
</para>
</refsect1>

<refsect1><title>Example</title>
<informalexample>
<programlisting>
periods 100;
</programlisting>
</informalexample>
</refsect1>
</refentry>

</sect1>

<sect1><title>Solving and simulating</title>
<para>
Dynare has special commands for the computation of the static equilibrium of the model (<xref linkend='steady'/>), of the eigenvalues of the linearized model (<xref linkend='check'/>) for dynamics local analysis, of a deterministic simulation (<xref linkend='simul'/>) and for solving and/or simulating a stochastic model (<xref linkend='stoch_simul'/>).
</para>
<itemizedlist>
<listitem><para><xref linkend='steady'/></para></listitem>
<listitem><para><xref linkend='homotopy_setup'/></para></listitem>
<listitem><para><xref linkend='check'/></para></listitem>
<listitem><para><xref linkend='simul'/></para></listitem>
<listitem><para><xref linkend='stoch_simul'/></para></listitem>
</itemizedlist>

<refentry id="steady">
  <refmeta>
    <refentrytitle>steady</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>steady</refname>
    <refpurpose>computes the steady state of a model</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>steady</command>
      <arg>(<replaceable>OPTION</replaceable><arg rep="repeat">, <replaceable>OPTION</replaceable></arg>)</arg><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Options</title>
<variablelist>
  <varlistentry id="solve_algo" xreflabel="solve_algo">
    <term><option>solve_algo</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Determines the non-linear solver to use. Possible values for the option are:
      <itemizedlist>
        <listitem><para><literal>0</literal>: uses <trademark class="registered">MATLAB</trademark> Optimization Toolbox FSOLVE</para></listitem>
        <listitem><para><literal>1</literal>: uses Dynare's own nonlinear equation solver</para></listitem>
        <listitem><para><literal>2</literal>: splits the model into recursive blocks and solves each block in turn</para></listitem>
        <listitem><para><literal>3</literal>: Chris Sims' solver</para></listitem>
        <listitem><para><literal>4</literal>: similar to value <literal>2</literal>, except that it deals differently with nearly singular Jacobian</para></listitem>
      </itemizedlist>
      Default value is <literal>2</literal>.
    </para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>homotopy_mode</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Use a homotopy (or divide-and-conquer) technique to solve for the steady state (see <xref linkend="homotopy_setup"/> for a short description of the technique). This option can take three possible values:
    <itemizedlist>
      <listitem><para><literal>1</literal>: in this mode, all the parameters are changed simultaneously, and the distance between the boudaries for each parameter is divided in as many intervals as there are steps (as defined by <option>homotopy_steps</option> option); the problem is solves as many times as there are steps</para></listitem>
      <listitem><para><literal>2</literal>: same as mode <literal>1</literal>, except that only one parameter is changed at a time; the problem is solved as many times as steps times number of parameters</para></listitem>
      <listitem><para><literal>3</literal>: Dynare tries first the most extreme values. If it fails to compute the steady state, the interval between initial and desired values is divided by two for all parameters. Every time that it is impossible to find a steady state, the previous interval is divided by two. When it succeeds to find a steady state, the previous interval is multiplied by two. In that last case <option>homotopy_steps</option> contains the maximum number of computations attempted before giving up.</para></listitem>
    </itemizedlist>
    </para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>homotopy_steps</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Defines the number of steps when performing a homotopy. See <option>homotopy_mode</option> option for more details.</para></listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1><title>Description</title>

<para>
Computes the equilibrium value of the endogenous variables for the value of the exogenous variables specified in the previous <xref linkend='initval'/> or <xref linkend='endval'/> block.
</para>
<para>
<command>steady</command> uses an iterative procedure and takes as initial guess the value of the endogenous variables set in the previous <xref linkend='initval'/> or <xref linkend='endval'/> block.
</para>
<para>
For complicated models, finding good numerical initial values for the endogenous variables is the trickiest part of finding the equilibrium of that model. Often, it is better to start with a smaller model and add new variables one by one.
</para>

<para>If you know how to compute the steady state for your model, you can provide a <trademark class="registered">MATLAB</trademark> function doing the computation instead of using <command>steady</command>. The function should be called with the name of the <filename class="extension">.mod</filename> file followed by <filename>_steadystate</filename>. See <filename>fs2000a_steadystate.m</filename> in <filename>examples/fs2000</filename> directory.
</para>

</refsect1>

<refsect1><title>Output variables</title>
<para>
  The steady state is available in <varname>oo_.steady_state</varname>. Endogenous variables are ordered in order of declaration used in <xref linkend="var"/> command as in <varname>M_.endo_names</varname>.  
</para>
</refsect1> 

<refsect1><title>Examples</title>
<para>
See <xref linkend='initval'/> and <xref linkend='endval'/>.
</para>
</refsect1>
</refentry>     

<refentry id="homotopy_setup">
  <refmeta>
    <refentrytitle>homotopy_setup</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>homotopy_setup</refname>
    <refpurpose>declare initial and final values when using homotopy method</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>homotopy_setup</command><arg choice="plain">;</arg><sbr/>
      <arg choice="plain" rep="repeat"><replaceable>VARIABLE_NAME</replaceable>, <replaceable>EXPRESSION</replaceable><arg>, <replaceable>EXPRESSION</replaceable></arg>;</arg><sbr/>
      <command>end</command><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1><title>Description</title>
  <para>The idea of homotopy (also called divide-and-conquer by some authors) is to subdivide the problem of finding the steady state into smaller problems. It assumes that you know how to compute the steady state for a given set of parameters, and it helps you finding the steady state for another set of parameters, by incrementally moving from one to another set of parameters.</para>

  <para>The purpose of the <command>homotopy_setup</command> block is to declare the final (and possibly also the initial) values for the parameters or exogenous that will be changed during the homotopy. In the first syntax where only one value is specified for a given parameter/exogenous, then this value is interpreted as the final value, and the initial value is taken from the preceeding <xref linkend="initval"/> block. In the second syntax where two values are specified for a given parameter/exogenous, the first is the initial one, the second is the final one.</para>

  <para>A necessary condition for a successful homotopy is that Dynare must be able to solve the steady state for the initial parameters/exogenous without additional help (using the guess values given in the <xref linkend="initval"/> block).</para>

  <para> If the homotopy fails, a possible solution is to increase the number of steps (given in <option>homotopy_steps</option> option of <xref linkend="steady"/>).</para>
  </refsect1>

  <refsect1><title>Example</title> 
  <informalexample>
    <para>In the following example, Dynare will first compute the steady state for the initial values (<literal>gam=0.5</literal> and <literal>x=1</literal>), and then subdivide the problem into 50 smaller problems to find the steady state for the final values (<literal>gam=2</literal> and <literal>x=2</literal>).</para>
    <programlisting>
var c k;
varexo x;

parameters alph gam delt bet aa;
alph=0.5;
delt=0.02;
aa=0.5;
bet=0.05;

model;
c + k - aa*x*k(-1)^alph - (1-delt)*k(-1);
c^(-gam) - (1+bet)^(-1)*(aa*alph*x(+1)*k^(alph-1) + 1 - delt)*c(+1)^(-gam);
end;

initval;
x = 1;
k = ((delt+bet)/(aa*x*alph))^(1/(alph-1));
c = aa*x*k^alph-delt*k;
end;

homotopy_setup;
gam, 0.5, 2;
x, 2;
end;

steady(homotopy_mode = 1, homotopy_steps = 50);
    </programlisting>
  </informalexample>
  </refsect1>

</refentry>

<refentry id="check">
  <refmeta>
    <refentrytitle>check</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>check</refname>
    <refpurpose>computes the eigenvalues of the (linearized) model</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>check</command>
      <arg>(<option>solve_algo</option> = <replaceable>INTEGER</replaceable>)</arg><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Options</title>
<variablelist>
  <varlistentry>
    <term><option>solve_algo</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>See <link linkend="solve_algo">there</link> for the possible values and their meaning</para></listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1><title>Description</title>
<para>
Computes the eigenvalues of the model linearized around the values specified by the last <xref linkend='initval'/>, <xref linkend='endval'/> or <xref linkend='steady'/> statement. Generally, the eigenvalues are only meaningful if the linearization is done around a steady state of the model. It is a device for local analysis in the neighborhood of this steady state.
</para>
<para>
A necessary condition for the uniqueness of a stable equilibrium in the neighborhood of the steady state is that there are as many eigenvalues larger than one in modulus as there are forward looking variables in the system. An additional rank condition requires that the square submatrix of the right Schur vectors corresponding to the forward looking variables (jumpers) and to the explosive eigenvalues must have full rank.
</para>
</refsect1>

<refsect1><title>Output variables</title>
<para>
<command>check</command> returns the eigenvalues in the global variable <varname>oo_.dr.eigval</varname>.
</para>
</refsect1>
</refentry>

<refentry id="simul">
  <refmeta>
    <refentrytitle>simul</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>simul</refname>
    <refpurpose>simulates a deterministic model</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>simul</command>
      <arg>(<option>periods</option>=<replaceable>INTEGER</replaceable>)
      </arg><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1><title>Description</title>
  <para>
    Triggers the computation of a deterministic simulation of the model for the number of periods set in the option <option>periods</option>. <command>simul</command> uses a Newton method to solve simultaneously all the equations for every period (see <xref linkend="juillard_1996"/>).
  </para>
  </refsect1>
<refsect1><title>Output variables</title>
<para>
The simulated endogenous variables are available in global matrix <varname>oo_.endo_simul</varname>. The variables are arranged row by row, in order of declaration (as in <varname>M_.endo_names</varname>). Note that this variable also contains initial and terminal conditions, so it has more columns than the value of <option>periods</option> option.
</para>
</refsect1>
</refentry>


<refentry id="stoch_simul">
  <refmeta>
    <refentrytitle>stoch_simul</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>stoch_simul</refname>
    <refpurpose>computes the solution and simulates the model</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>stoch_simul</command>
      <arg>(<replaceable>OPTION</replaceable><arg rep="repeat">, <replaceable>OPTION</replaceable></arg>)</arg>
      <arg rep="repeat"><replaceable>VARIABLE_NAME</replaceable></arg><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Options</title>
<variablelist>
  <varlistentry>
    <term><anchor id="ar" xreflabel="ar"/><option>ar</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Order of autocorrelation coefficients to compute and to print. Default: <literal>5</literal></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>drop</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Number of points dropped at the beginning of simulation before computing the summary statistics. Default: <literal>100</literal></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>hp_filter</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Uses HP filter with &lambda; = <replaceable>INTEGER</replaceable> before computing moments. Note that this option is currently not available when computing empirical moments (see <option>periods</option> option). Default: no filter</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>hp_ngrid</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Number of points in the grid for the discrete Inverse Fast Fourier Transform used in the HP filter computation. It may be necessary to increase it for highly autocorrelated processes. Default: <literal>512</literal></para></listitem>
  </varlistentry>
  <varlistentry id="irf" xreflabel="irf">
    <term><option>irf</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Number of periods on which to compute the IRFs. Setting <option>irf</option>=0, suppresses the plotting of IRF's. Default: <literal>40</literal></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>relative_irf</option></term>
    <listitem><para>Requests the computation of normalized IRFs in percentage of the standard error of each shock</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>linear</option></term>
    <listitem><para>Indicates that the original model is linear (put it rather in the <xref linkend="model"/> command)</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>nocorr</option></term>
    <listitem><para>Don't print the correlation matrix (printing them is the default)</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>nofunctions</option></term>
    <listitem><para>Don't print the coefficients of the approximated solution (printing them is the default)</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>nomoments</option></term>
    <listitem><para>Don't print moments of the endogenous variables (printing them is the default)</para></listitem>
  </varlistentry>
  <varlistentry id="nograph" xreflabel="nograph">
    <term><option>nograph</option></term>
    <listitem><para>Doesn't do the graphs. Useful for loops</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>noprint</option></term>
    <listitem><para>Don't print anything. Useful for loops</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>print</option></term>
    <listitem><para>Print results (opposite of the above)</para></listitem>
  </varlistentry>
  <varlistentry id="order" xreflabel="order">
    <term><option>order = <replaceable>INTEGER</replaceable></option></term>
    <listitem><para>Order of Taylor approximation. Acceptable values are <literal>1</literal>, <literal>2</literal> and <literal>3</literal>. Note that for third order, <option>k_order_solver</option> option is implied, and only empirical moments are available (you must provide a value for <option>periods</option> option). Default: <literal>2</literal></para></listitem>
  </varlistentry>
    <varlistentry id="k_order_solver">
      <term><option>k_order_solver</option></term>
      <listitem><para>Use a k-order solver, implemented in C++, instead of the default Dynare solver. When using this option, you must specify the <xref linkend="use_dll"/> option, and you need a working compilation environment, <foreignphrase>i.e.</foreignphrase> a working <literal>mex</literal> command (see <xref linkend="software-requirements"/> for more details). Default: disabled for order 1 and 2, enabled otherwise</para></listitem>
    </varlistentry>
  <varlistentry>
    <term><option>periods</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>If different from zero, empirical moments will be computed instead of theoretical moments. The value of the option specifies the number of periods to use in the simulations. Values of the <xref linkend='initval'/> block, possibly recomputed by <xref linkend='steady'/>, will be used as starting point for the simulation. The simulated endogenous variables are made available to the user in a vector for each variable and in the global matrix <varname>oo_.endo_simul</varname>. The variables in the <varname>oo_.endo_simul</varname> matrix, in their order of declaration (as in <varname>M_.endo_names</varname>) Default: <literal>0</literal></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>qz_criterium</option> = <replaceable>DOUBLE</replaceable></term>
    <listitem><para>Value used to split stable from unstable eigenvalues in reordering the Generalized Schur decomposition used for solving 1<superscript>st</superscript> order problems. Default: <literal>1.000001</literal></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>replic</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Number of simulated series used to compute the IRFs. Default: <literal>1</literal> if <option>order</option>=<literal>1</literal>, and <literal>50</literal> otherwise</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>simul_seed</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Specifies a seed for the random generator so as to obtain the same random sample at each run of the program. Otherwise a different sample is used for each run. Default: seed not specified</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>simul_algo</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Obsolete. Use only the default = 0</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>solve_algo</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>See <link linkend="solve_algo">there</link> for the possible values and their meaning</para></listitem>
  </varlistentry>
  <varlistentry id="aim_solver">
    <term><option>aim_solver</option></term>
    <listitem><para>Use the Anderson-Moore Algorithm (AIM) to compute the decision rules, instead of using Dynare's default method based on a generalized Schur decomposition. This option is only valid for first order approximation. See <ulink url="http://www.federalreserve.gov/Pubs/oss/oss4/aimindex.html">AIM website</ulink> for more details on the algorithm.</para>
    </listitem>
  </varlistentry>
  <varlistentry id="conditional_variance_decomposition">
    <term><option>conditional_variance_decomposition</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>See below</para></listitem>
  </varlistentry>
 <varlistentry>
    <term><option>conditional_variance_decomposition</option> = [<replaceable>INTEGER1</replaceable>:<replaceable>INTEGER2</replaceable>]</term>
    <listitem><para>See below</para></listitem>
 </varlistentry>
 <varlistentry>
    <term><option>conditional_variance_decomposition</option> = [<replaceable>INTEGER1</replaceable> <replaceable>INTEGER2</replaceable> ...]</term>
<listitem><para>Computes a conditional variance decomposition for the specified period(s). Conditional variances are given by var(y<subscript>t+k</subscript>|t). For period 1, the conditional variance decomposition provides the decomposition of the effects of shocks upon impact.</para></listitem>
</varlistentry>    
</variablelist>

</refsect1>
<refsect1><title>Description</title>
<para>
<command>stoch_simul</command> computes a Taylor approximation of the decision and transition functions for the model, impulse response functions and various descriptive statistics (moments, variance decomposition, correlation and autocorrelation coefficients). For correlated shocks, the variance decomposition is computed as in the VAR literature through a Cholesky decomposition of the covariance matrix of the exogenous variables. When the shocks are correlated, the variance decomposition depends upon the order of the variables in the <xref linkend='varexo'/> command.
</para>

<para>The Taylor approximation is computed around the steady state. If you know how to compute the steady state for your model, you can provide a <trademark class="registered">MATLAB</trademark> function doing the computation instead of using the nonlinear solver. The function should be called with the name of the <filename class="extension">.mod</filename> file followed by <filename>_steadystate</filename>. See <filename>fs2000a_steadystate.m</filename> in <filename>examples/fs2000</filename> directory.
</para>

<para>The IRFs are computed as the difference between the trajectory of a variable following a shock at the beginning of period 1 and its steady state value.
</para>

<para>
Variance decomposition, correlation, autocorrelation are only displayed for variables with positive variance. Impulse response functions are only plotted for variables with response larger than 10<superscript>-10</superscript>.
</para>
<para>
Currently, the IRFs are only plotted for 12 variables. Select the ones you want to see, if your model contains more than 12 endogenous variables.
</para>
<para>Currently, the HP filter is only available when computing theoretical moments, not for for moments of simulated variables.
</para>
<para>
The covariance matrix of the shocks is specified either with the <xref linkend='shocks'/> command or with the <xref linkend='Sigma_e'/> command.
</para>
<para>
When a list of <replaceable>VARIABLE_NAME</replaceable> is specified, results are displayed only for these variables.
</para>
</refsect1>

<refsect1><title>Decision rules</title>
<para>
The approximated solution of a model takes the form of a set of decision rules or transition equations expressing the current value of the endogenous variables of the model as function of the previous state of the model and shocks oberved at the beginning of the period.
</para>
<refsect2><title>First order approximation</title>
<blockquote><para>
y<subscript>t</subscript> = ys + A yh<subscript>t-1</subscript> + B u<subscript>t</subscript>
</para>
<para>
where ys is the steady state value of y and yh<subscript>t</subscript>=y<subscript>t</subscript>-ys.
</para>
</blockquote>
</refsect2>
<refsect2><title>Second order approximation</title>
<blockquote><para>
y<subscript>t</subscript> = ys + 0.5&Delta;<superscript>2</superscript> + A yh<subscript>t-1</subscript> + B u<subscript>t</subscript> + 0.5C(yh<subscript>t-1</subscript>&otimes;yh<subscript>t-1</subscript>) + 0.5D(u<subscript>t</subscript>&otimes;u<subscript>t</subscript>) + E(yh<subscript>t-1</subscript>&otimes;u<subscript>t</subscript>)
</para>
<para>
where ys is the steady state value of y, yh<subscript>t</subscript>=y<subscript>t</subscript>-ys, and &Delta;<superscript>2</superscript> is the shift effect of the variance of future shocks.
</para>
</blockquote>
</refsect2>
</refsect1>

<refsect1><title>Output variables</title>
<para>
<command>stoch_simul</command> sets several fields in global variable <varname>oo_</varname>. The descriptive statistics are theoretical moments when no simulation is requested and otherwise represent the moments of the simulated variables. 
<itemizedlist>
<listitem><para>the coefficients of the decision rules are stored in global structure <varname>oo_.dr</varname>. Here is the correspondance with the symbols used in the above description of the decision rules:
<itemizedlist><title>Decision rule coefficients</title>

<listitem><para><varname>ys</varname>: <varname>oo_.dr.ys</varname>. The vector rows correspond to variables in the declaration order of the variable names.</para></listitem>
<listitem><para>&Delta;<superscript>2</superscript>: <varname>oo_.dr.ghs2</varname>. The vector rows correspond to re-ordered variables (see below).</para></listitem>
<listitem><para><varname>A</varname>: <varname>oo_.dr.ghx</varname>. The matrix rows correspond to re-ordered variables (see below). The matrix columns correspond to state variables (see below).</para></listitem>
<listitem><para><varname>B</varname>: <varname>oo_.dr.ghu</varname>. The matrix rows correspond to re-ordered variables (see below). The matrix columns correspond to exogenous variables in declaration order.</para></listitem>
<listitem><para><varname>C</varname>: <varname>oo_.dr.ghxx</varname>. The matrix rows correspond to re-ordered variables (see below). The matrix columns correspond to the Kronecker product of the vector of state variables (see below).</para></listitem>
<listitem><para><varname>D</varname>: <varname>oo_.dr.ghuu</varname>. The matrix rows correspond to re-ordered variables (see below). The matrix columns correspond to the Kronecker product of exogenous variables in declaration order.</para></listitem>
<listitem><para><varname>E</varname>: <varname>oo_.dr.ghxu</varname>. The matrix rows correspond to re-ordered variables (see below). The matrix columns correspond to the Kronecker product of the vector of state variables (see below) by the vector of exogenous variables in declaration order.</para></listitem>
</itemizedlist>
When reordered, the variables are stored in the following order: static variables, purely predetermined variables (variables that appear only at the current and lagged periods in the model), variables that are both predetermined and forward-looking (variables that appear at the current, future and lagged periods in the model), purely forward-looking variables (variables that appear only at the current and future periods in the model). In each category, the variables are arranged in declaration order. Variable <varname>oo_.dr.order_var</varname> maps reordered variables to declaration order, and variable <varname>oo_.dr.inv_order_var</varname> contains the inverse map. In other words, the first row in transition matrices corresponds to the endogenous declared at position <varname>oo_.dr_order_var(1)</varname>; conversely, first declared variable has row <varname>oo_.dr.inv_order_var(1)</varname> in transition matrices.</para>
<para>
The state variables of the model are purely predetermined variables and variables that are both predetermined and forward-looking. They are ordered in that order. When there are lags on more than one period, the state variables are ordered first according to their lag: first variables from the previous period, then variables from two periods before and so on. Note also that when a variable appears in the model at a lag larger than one period, it is automatically included at all inferior lags.
</para>
</listitem>
<listitem><para>The mean of the endogenous variables is available in the vector <varname>oo_.mean</varname>. The variables are arranged in declaration order.
</para></listitem>
<listitem><para>The matrix of variance-covariance of the endogenous variables in the matrix <varname>oo_.var</varname>. The variables are arranged in declaration order.</para></listitem>
<listitem><para>The matrix of autocorrelation of the endogenous variables are made available in cell array <varname>oo_.autocorr</varname>. The element number of the matrix in the cell array corresponds to the order of autocorrelation. The option <option>ar</option> specifies the number of autocorrelation matrices available.
</para></listitem>
<listitem>
<para>
  Simulated variables, when they have been computed, are available in <trademark class="registered">MATLAB</trademark>
vectors with the same name as the endogenous variables. They are also available in the <varname>oo_.endo_simul</varname> matrix. The series are arranged by row, in declaration order of the variable names</para>
</listitem>
<listitem>
<para>
  Impulse responses, when they have been computed, are available in <varname>oo_.irfs</varname>, with the following naming convention: <varname><replaceable>VARIABLE_NAME</replaceable>_<replaceable>SHOCK_NAME</replaceable></varname>.</para>

<para>(DEPRECATED) They are currently also available in <trademark class="registered">MATLAB</trademark> vectors in the global workspace, however they will disappear there in a future version.
</para>
<informalexample>
  <para>Example:
    <varname>oo_.irfs.gnp_ea</varname> contains the effect on <varname>gnp</varname> of a one standard deviation shock on <varname>ea</varname>.
  </para>
</informalexample>
</listitem>
</itemizedlist>
</para>
</refsect1>

<refsect1><title>Examples</title>
<refsect2><title>Example 1</title>
<informalexample>
<programlisting>
shocks;
var e;
stderr 0.0348;
end;

stoch_simul;
</programlisting>
<para>
Performs the simulation of the 2<superscript>nd</superscript> order approximation of a model with a single stochastic shock <varname>e</varname>, with a standard error of 0.0348.
</para>
</informalexample>
</refsect2>

<refsect2><title>Example 2</title>

<informalexample>
<programlisting>
stoch_simul(linear,irf=60) y k;
</programlisting>
<para>
Performs the simulation of a linear model and displays impulse response functions on 60 periods for variables <varname>y</varname> and <varname>k</varname>.
</para>
</informalexample>
</refsect2>
</refsect1>
</refentry>
</sect1>

<sect1><title>Estimation</title>
<para>
Provided that you have observations on some endogenous variables, it is possible to use Dynare to estimate some or all parameters. Both maximum likelihood and Bayesian techniques are available.
</para>

<para>
Note that in order to avoid stochastic singularity, you must have at least as many shocks or measurement errors in your model as you have observed variables. 
</para>
<itemizedlist>
<listitem><para><xref linkend='varobs'/></para></listitem>
<listitem><para><xref linkend='observation_trends'/></para></listitem>
<listitem><para><xref linkend='estimated_params'/></para></listitem>
<listitem><para><xref linkend='estimated_params_init'/></para></listitem>
<listitem><para><xref linkend='estimated_params_bounds'/></para></listitem>
<listitem><para><xref linkend='estimation'/></para></listitem>
<listitem><para><xref linkend='prior_analysis'/></para></listitem>
<listitem><para><xref linkend='posterior_analysis'/></para></listitem>
<listitem><para><xref linkend='model_comparison'/></para></listitem>
<listitem><para><xref linkend='shock_decomposition'/></para></listitem>
<listitem><para><xref linkend='unit_root_vars'/> (deprecated)</para></listitem>
</itemizedlist>

<refentry id="varobs">
  <refmeta>
    <refentrytitle>varobs</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>varobs</refname>
    <refpurpose>lists the observed variables</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>varobs</command>
      <arg choice="plain" rep="repeat">
	      <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
<command>varobs</command> lists the name of observed endogenous variables for the estimation procedure. These variables must be available in the data file (see <xref linkend='estimation'/>).
</para>
</refsect1>

<refsect1><title>Example</title>
  <informalexample>
<programlisting>
varobs C y rr;
</programlisting>
  </informalexample>
</refsect1>

</refentry>

<refentry id="observation_trends">
  <refmeta>
    <refentrytitle>observation_trends</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>observation_trends</refname>
    <refpurpose>specifies linear trends for observed variables</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>observation_trends</command><arg choice="plain">;</arg><sbr/>
      <arg choice="plain" rep="repeat">
	      <replaceable>VARIABLE_NAME</replaceable>(<replaceable>EXPRESSION</replaceable>);
      </arg><sbr/>
	    <command>end</command><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
<command>observation_trends</command> specifies trends for observed variables as functions of model parameters. In most cases, variables shouldn't be centered when <command>observation_trends</command> is used. 
</para>
</refsect1>

<refsect1><title>Example</title>
  <informalexample>
<programlisting>
observation_trends;
Y (eta);
P (mu/eta);
end;
</programlisting>
  </informalexample>
</refsect1>

</refentry>

<refentry id="estimated_params">
  <refmeta>
    <refentrytitle>estimated_params</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>estimated_params</refname>
    <refpurpose>specifies the estimated parameters and their prior</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <refsect2><title>Syntax I (Maximum likelihood estimation)</title>
      <cmdsynopsis>
        <command>estimated_params</command><arg choice="plain">;</arg><sbr/>
        <arg choice="plain" rep="repeat">
          <group choice="req">
            <arg choice="plain">
	            <option>stderr</option> <replaceable>VARIABLE_NAME</replaceable>
            </arg>
            <arg choice="plain">
	            <option>corr</option> <replaceable>VARIABLE_NAME_1</replaceable>, <replaceable>VARIABLE_NAME_2</replaceable>
            </arg>
            <arg choice="plain">
	            <replaceable>PARAMETER_NAME</replaceable>
	          </arg>
          </group>
          ,
	        <arg choice="plain">
	          <replaceable>INITIAL_VALUE</replaceable>
	        </arg>
	        <arg>
	          , <replaceable>LOWER_BOUND</replaceable>
	          , <replaceable>UPPER_BOUND</replaceable>
	        </arg>
          ;
        </arg><sbr/>
	      <command>end</command><arg choice="plain">;</arg>
      </cmdsynopsis>
    </refsect2>
    <refsect2>
      <title>Syntax II (Bayesian estimation)</title>
      <cmdsynopsis>
        <command>estimated_params</command><arg choice="plain">;</arg><sbr/>
        <arg choice="plain" rep="repeat">
          <group choice="req">
            <arg choice="plain">
	            <option>stderr</option> <replaceable>VARIABLE_NAME</replaceable>
            </arg>
            <arg choice="plain">
	            <option>corr</option> <replaceable>VARIABLE_NAME_1</replaceable>, <replaceable>VARIABLE_NAME_2</replaceable>
            </arg>
            <arg choice="plain">
	            <replaceable>PARAMETER_NAME</replaceable>
	          </arg>
          </group>
	        <arg>
	          , <replaceable>INITIAL_VALUE</replaceable>
	          <arg>
	            , <replaceable>LOWER_BOUND</replaceable>
	            , <replaceable>UPPER_BOUND</replaceable>
	          </arg>
	        </arg>

          <arg choice="plain">
	          , <synopfragmentref linkend="prior_shape">PRIOR_SHAPE</synopfragmentref>
          </arg>
          <arg choice="plain">
	          , <replaceable>PRIOR_MEAN</replaceable>
          </arg>
          <arg choice="plain">
	          , <replaceable>PRIOR_STANDARD_ERROR</replaceable>
          </arg>
          <arg>
	          , <replaceable>PRIOR_3RD_PARAMETER</replaceable>
            <arg>
	            , <replaceable>PRIOR_4TH_PARAMETER</replaceable>
              <arg>
	              , <replaceable>SCALE_PARAMETER</replaceable>
              </arg>
            </arg>
          </arg>
          ;
        </arg><sbr/>
	      <command>end</command><arg choice="plain">;</arg>

        <synopfragment id="prior_shape">
          <group choice="plain">
            <arg choice="plain"><option>beta_pdf</option></arg>
            <arg choice="plain"><option>gamma_pdf</option></arg>
            <arg choice="plain"><option>normal_pdf</option></arg>
            <arg choice="plain"><option>uniform_pdf</option></arg>
            <arg choice="plain"><option>inv_gamma_pdf</option></arg>
            <arg choice="plain"><option>inv_gamma1_pdf</option></arg>
            <arg choice="plain"><option>inv_gamma2_pdf</option></arg>
          </group>
        </synopfragment>
      </cmdsynopsis>
    </refsect2>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
  The <command>estimated_params</command> block lists all parameters to be estimated and specifies bounds and priors as necessary.
</para>
</refsect1>

<refsect1><title>Estimated parameter specification</title>
<para>
Each line corresponds to an estimated parameter and follows this syntax:
<variablelist>
  <varlistentry>
    <term><option>stderr</option> <replaceable>VARIABLE_NAME</replaceable></term>
    <listitem><para>Indicates that the standard error of the exogenous variable <replaceable>VARIABLE_NAME</replaceable>, or of the observation error associated with endogenous observed variable <replaceable>VARIABLE_NAME</replaceable>, is to be estimated</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>corr</option> <replaceable>VARIABLE_NAME_1</replaceable>, <replaceable>VARIABLE_NAME_2</replaceable></term>
    <listitem><para>Indicates that the correlation between the exogenous variables <replaceable>VARIABLE_NAME_1</replaceable> and <replaceable>VARIABLE_NAME_2</replaceable>, or the correlation of the observation errors associated with endogenous observed variables <replaceable>VARIABLE_NAME_1</replaceable> and <replaceable>VARIABLE_NAME_2</replaceable>, is to be estimated</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><replaceable>PARAMETER_NAME</replaceable></term>
    <listitem><para>The name of a model parameter to be estimated</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><replaceable>INITIAL_VALUE</replaceable></term>
    <listitem><para>Specifies a starting value for maximum likelihood estimation</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><replaceable>LOWER_BOUND</replaceable></term>
    <listitem><para>Specifies a lower bound for the parameter value in maximum likelihood estimation</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><replaceable>UPPER_BOUND</replaceable></term>
    <listitem><para>Specifies an upper bound for the parameter value in maximum likelihood estimation</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><replaceable>PRIOR_SHAPE</replaceable></term>
    <listitem><para>A keyword specifying the shape of the prior density. See the <link linkend="prior_shape">list of possible values</link>. Note that <option>inv_gamma_pdf</option> is equivalent to <option>inv_gamma1_pdf</option></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><replaceable>PRIOR_MEAN</replaceable></term>
    <listitem><para>The mean of the prior distribution</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><replaceable>PRIOR_STANDARD_ERROR</replaceable></term>
    <listitem><para>The standard error of the prior distribution</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><replaceable>PRIOR_3RD_PARAMETER</replaceable></term>
    <listitem><para>A third parameter of the prior used for generalized beta distribution, generalized gamma and for the uniform distribution. Default: <literal>0</literal></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><replaceable>PRIOR_4TH_PARAMETER</replaceable></term>
    <listitem><para>A fourth parameter of the prior used for generalized beta distribution, generalized gamma and for the uniform distribution. Default: <literal>1</literal></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><replaceable>SCALE_PARAMETER</replaceable></term>
    <listitem><para>The scale parameter to be used for the jump distribution of the Metropolis-Hasting algorithm</para></listitem>
  </varlistentry>
</variablelist>

<note>
<para><replaceable>INITIAL_VALUE</replaceable>, <replaceable>LOWER_BOUND</replaceable>, <replaceable>UPPER_BOUND</replaceable>, <replaceable>PRIOR_MEAN</replaceable>, <replaceable>PRIOR_STANDARD_ERROR</replaceable>, <replaceable>PRIOR_3RD_PARAMETER</replaceable>, <replaceable>PRIOR_4TH_PARAMETER</replaceable> and <replaceable>SCALE_PARAMETER</replaceable> can be any valid <replaceable>EXPRESSION</replaceable>. Some of them can be empty, in which Dynare will select a default value depending on the context and the prior shape.</para>
</note>

<note><para>At minimum, one must specify the name of the parameter and an initial guess. That will trigger unconstrained maximum likelihood estimation.
</para></note>

<note><para>As one uses options more towards the end of the list, all previous options must be filled: for example, if you want to specify <replaceable>SCALE_PARAMETER</replaceable>, you must specify <replaceable>PRIOR_3RD_PARAMETER</replaceable> and <replaceable>PRIOR_4TH_PARAMETER</replaceable>. Use empty values, if these parameters don't apply. 
</para></note>
</para>
</refsect1>

<refsect1><title>Parameter transformation</title>
<para>
Sometimes, it is desirable to estimate a transformation of a parameter appearing in the model, rather than the parameter itself. It is of course possible to replace the original parameter by a function of the estimated parameter everywhere is the model, but it is often unpractical.
</para>

<para>
In such a case, it is possible to declare the parameter to be estimated in the <xref linkend="parameters"/> statement and to define the transformation, using a pound sign (#) expression (see <xref linkend="model"/>).
</para>
</refsect1>

<refsect1><title>Example</title>
  <informalexample>
<programlisting>
parameters bet;

model;
# sig = 1/bet;
c = sig*c(+1)*mpk;
end;

estimated_params;
bet, normal_pdf, 1, 0.05;
end;
</programlisting>
  </informalexample>
</refsect1>



</refentry>

<refentry id="estimated_params_init">
  <refmeta>
    <refentrytitle>estimated_params_init</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>estimated_params_init</refname>
    <refpurpose>specifies initial values for optimization</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>estimated_params_init</command><arg choice="plain">;</arg><sbr/>
        <arg choice="plain" rep="repeat">
          <group choice="req">
            <arg choice="plain">
	            <option>stderr</option> <replaceable>VARIABLE_NAME</replaceable>
            </arg>
            <arg choice="plain">
	            <option>corr</option> <replaceable>VARIABLE_NAME_1</replaceable>, <replaceable>VARIABLE_NAME_2</replaceable>
            </arg>
            <arg choice="plain">
	            <replaceable>PARAMETER_NAME</replaceable>
	          </arg>
          </group>
          ,
	        <arg choice="plain">
	          <replaceable>INITIAL_VALUE</replaceable>
	        </arg>
          ;
        </arg><sbr/>
	      <command>end</command><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>The <command>estimated_params_init</command> block declares numerical initial values for the optimizer when these ones are different from the prior mean.
</para>
</refsect1>

<refsect1><title>Estimated parameter initial value specification</title>
<para>See <xref linkend="estimated_params" /> for the meaning and syntax of the various components.</para>
</refsect1>

</refentry>

<refentry id="estimated_params_bounds">
  <refmeta>
    <refentrytitle>estimated_params_bounds</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>estimated_params_bounds</refname>
    <refpurpose>specifies lower and upper bounds for the estimated parameters</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>estimated_params_bounds</command><arg choice="plain">;</arg><sbr/>
      <arg choice="plain" rep="repeat">
        <group choice="req">
          <arg choice="plain">
	          <option>stderr</option> <replaceable>VARIABLE_NAME</replaceable>
          </arg>
          <arg choice="plain">
	          <option>corr</option> <replaceable>VARIABLE_NAME_1</replaceable>, <replaceable>VARIABLE_NAME_2</replaceable>
          </arg>
          <arg choice="plain">
	          <replaceable>PARAMETER_NAME</replaceable>
	        </arg>
        </group>
        ,
	      <arg choice="plain">
          <replaceable>LOWER_BOUND</replaceable>
	      </arg>
        ,
	      <arg choice="plain">
	        <replaceable>UPPER_BOUND</replaceable>
	      </arg>
        ;
      </arg><sbr/>
	    <command>end</command><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>The <command>estimated_params_bounds</command> block declares lower and upper bounds for parameters in maximum likelihood estimation.</para>
</refsect1>

<refsect1><title>Estimated parameter bounds specification</title>
<para>See <xref linkend="estimated_params" /> for the meaning and syntax of the various components.</para>
</refsect1>

</refentry>

<refentry id="estimation">
 <refmeta>
    <refentrytitle>estimation</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>estimation</refname>
    <refpurpose>computes estimation</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>estimation</command>
      <arg>(<replaceable>OPTION</replaceable><arg rep="repeat">, <replaceable>OPTION</replaceable></arg>)</arg>
      <arg rep="repeat"><replaceable>VARIABLE_NAME</replaceable></arg><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Options</title>
<variablelist>
  <varlistentry>
    <term><option>datafile</option> = <replaceable>FILENAME</replaceable></term>
    <listitem><para>The datafile (a <filename class="extension">.m</filename> file, a <filename class="extension">.mat</filename> file or a <filename class="extension">.xls</filename> file)</para></listitem>
  </varlistentry>
  <varlistentry id="xls_sheet" xreflabel="xls_sheet">
    <term><option>xls_sheet</option> = <replaceable>NAME</replaceable></term>
    <listitem><para>The name of the sheet with the data in an Excel file</para></listitem>
  </varlistentry>
  <varlistentry id="xls_range" xreflabel="xls_range">
    <term><option>xls_range</option> = <replaceable>RANGE</replaceable></term>
    <listitem><para>The range with the data in an Excel file</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>nobs</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>The number of observations to be used. Default: all observations in the file</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>nobs</option> = [<replaceable>INTEGER_1</replaceable>:<replaceable>INTEGER_2</replaceable>]</term>
    <listitem><para>Runs a recursive estimation and forecast for samples of size ranging of <replaceable>INTEGER_1</replaceable> to <replaceable>INTEGER_2</replaceable>. Option <option>forecast</option> must also be specified</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>first_obs</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>The number of the first observation to be used. Default: <literal>1</literal></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>prefilter</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>A value of <literal>1</literal> means that the estimation procedure will demean the data. Default: <literal>0</literal>, <foreignphrase>i.e.</foreignphrase> no prefiltering</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>presample</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>The number of observations to be skipped before evaluating the likelihood. Default: <literal>0</literal></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>loglinear</option></term>
    <listitem><para>Computes a log--linear approximation of the model instead of a linear approximation. The data must correspond to the definition of the variables used in the model. Default: computes a linear approximation</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>nograph</option></term>
    <listitem><para>No graphs should be plotted</para></listitem>
  </varlistentry>
  <varlistentry id="lik_init" xreflabel="lik_init">
    <term><option>lik_init</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Type of initialization of Kalman filter:
        <itemizedlist>
          <listitem><para><literal>1</literal>: for stationary models, the initial matrix of variance of the error of forecast is set equal to the unconditional variance of the state variables</para></listitem>
          <listitem><para><literal>2</literal>: for nonstationary models: a wide prior is used with an initial matrix of variance of the error of forecast diagonal with 10 on the diagonal</para></listitem>
        </itemizedlist>
        Default value is <literal>1</literal>.
    </para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>lik_algo</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>...</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>conf_sig</option> = <replaceable>DOUBLE</replaceable></term>
    <listitem><para>See <link linkend="conf_sig">there</link></para></listitem>
  </varlistentry>
  <varlistentry id="mh_replic" xreflabel="mh_replic">
    <term><option>mh_replic</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Number of replications for Metropolis-Hastings algorithm. For the time being, <option>mh_replic</option> should be larger than <literal>1200</literal>. Default: <literal>20000</literal></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>mh_nblocks</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Number of parallel chains for Metropolis-Hastings algorithm. Default: <literal>2</literal></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>mh_drop</option> = <replaceable>DOUBLE</replaceable></term>
    <listitem><para>The fraction of initially generated parameter vectors to be dropped before using posterior simulations. Default: <literal>0.5</literal></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>mh_jscale</option> = <replaceable>DOUBLE</replaceable></term>
    <listitem><para>The scale to be used for the jumping distribution in Metropolis-Hastings algorithm. The default value is rarely satisfactory. This option must be tuned to obtain, ideally, an acceptation rate of 25% in the Metropolis-Hastings algorithm. Default: <literal>0.2</literal></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>mh_init_scale</option> = <replaceable>DOUBLE</replaceable></term>
    <listitem><para>The scale to be used for drawing the initial value of the Metropolis-Hastings chain. Default: 2*<option>mh_scale</option></para></listitem>
  </varlistentry>
  <varlistentry id="mh_recover" xreflabel="mh_recover">
    <term><option>mh_recover</option></term>
    <listitem><para>Attempts to recover a Metropolis-Hastings simulation that crashed prematurely. Shouldn't be used together with <xref linkend="load_mh_file"/></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>mh_mode</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>...</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>mode_file</option> = <replaceable>FILENAME</replaceable></term>
    <listitem><para>Name of the file containing previous value for the mode. When computing the mode, Dynare stores the mode (<varname>xparam1</varname>) and the hessian (<varname>hh</varname>) in a file called <filename><replaceable>MODEL_FILENAME</replaceable>_mode.mat</filename></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>mode_compute</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Specifies the optimizer for the mode computation:
        <itemizedlist>
          <listitem><para><literal>0</literal>: the mode isn't computed. mode_file must be specified</para></listitem>
          <listitem><para><literal>1</literal>: uses <trademark class="registered">MATLAB</trademark>'s <command>fmincon</command></para></listitem>
          <listitem><para><literal>2</literal>: value no longer used</para></listitem>
          <listitem><para><literal>3</literal>: uses <trademark class="registered">MATLAB</trademark>'s <command>fminunc</command></para></listitem>
          <listitem><para><literal>4</literal>: uses Chris Sim's <command>csminwel</command></para></listitem>
          <listitem><para><literal>5</literal>: uses a routine by Marco Ratto</para></listitem> 
          <listitem><para><literal>6</literal>: uses a simulated annealing-like algorithm</para></listitem>
          <listitem><para><literal>7</literal>: uses <trademark class="registered">MATLAB</trademark>'s <command>fminsearch</command> (a simplex based routine)</para></listitem>
        </itemizedlist>
        Default value is <literal>4</literal>.
    </para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>mode_check</option></term>
    <listitem><para>Tells Dynare to plot the posterior density for values around the computed mode for each estimated parameter in turn. This is helpful to diagnose problems with the optimizer</para></listitem>
  </varlistentry>
  <varlistentry id="prior_trunc" xreflabel="prior_trunc">
    <term><option>prior_trunc</option> = <replaceable>DOUBLE</replaceable></term>
    <listitem><para>Probability of extreme values of the prior density that is ignored when computing bounds for the parameters. Default: <literal>1e-32</literal></para></listitem>
  </varlistentry>
  <varlistentry id="load_mh_file" xreflabel="load_mh_file">
    <term><option>load_mh_file</option></term>
    <listitem><para>Tells Dynare to add to previous Metropolis-Hastings simulations instead of starting from scratch. Shouldn't be used together with <xref linkend="mh_recover"/></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>optim</option> = (<replaceable>fmincon options</replaceable>)</term>
    <listitem><para>Can be used to set options for <command>fmincon</command>, the optimizing function of <trademark class="registered">MATLAB</trademark> Optimizaiton toolbox. Use <trademark class="registered">MATLAB</trademark>'s syntax for these options. Default: <literal>('display','iter','LargeScale','off','MaxFunEvals',100000,'TolFun',1e-8,'TolX',1e-6)</literal></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>nodiagnostic</option></term>
    <listitem><para>Doesn't compute the convergence diagnostics for Metropolis-Hastings. Default: diagnostics are computed and displayed</para></listitem>
  </varlistentry>
  <varlistentry id="bayesian_irf" xreflabel="bayesian_irf">
    <term><option>bayesian_irf</option></term>
    <listitem><para>Triggers the computation of the posterior distribution of IRFs. The length of the IRFs are controlled by the <option>irf</option> option</para></listitem>
  </varlistentry>
  <varlistentry id="moments_varendo" xreflabel="moments_varendo">
    <term><option>moments_varendo</option></term>
    <listitem><para>Triggers the computation of the posterior distribution of the theoretical moments of the endogenous variables</para></listitem>
  </varlistentry>
  <varlistentry id="filtered_vars" xreflabel="filtered_vars">
    <term><option>filtered_vars</option></term>
    <listitem><para>Triggers the computation of the posterior distribution of filtered endogenous variables and shocks</para></listitem>
  </varlistentry>
  <varlistentry id="smoother" xreflabel="smoother">
    <term><option>smoother</option></term>
    <listitem><para>Triggers the computation of the posterior distribution of smoothered endogenous variables and shocks</para></listitem>
  </varlistentry>
  <varlistentry id="forecast_opt" xreflabel="forecast">
    <term><option>forecast</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Computes the posterior distribution of a forecast on <replaceable>INTEGER</replaceable> periods after the end of the sample used in estimation</para></listitem>
  </varlistentry>
  <varlistentry id="tex" xreflabel="tex">
    <term><option>tex</option></term>
    <listitem><para>Requests the printing of results and graphs in TeX tables and graphics that can be later directly included in LaTeX files (not yet implemented)</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>kalman_algo</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>...</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>kalman_tol</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>...</para></listitem>
  </varlistentry>
  <varlistentry id="filter_step_ahead" xreflabel="filter_step_ahead">
    <term><option>filter_step_ahead</option> = [<replaceable>INTEGER_1</replaceable>:<replaceable>INTEGER_2</replaceable>]</term>
    <listitem><para>...</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>constant</option></term>
    <listitem><para>...</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>noconstant</option></term>
    <listitem><para>...</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>diffuse_filter</option></term>
    <listitem><para>...</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>solve_algo</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>See <link linkend="solve_algo">there</link></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>order</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>See <link linkend="order">there</link></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>irf</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>See <link linkend="irf">there</link></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>aim_solver</option></term>
    <listitem><para>See <link linkend="aim_solver">there</link></para></listitem>
  </varlistentry>
</variablelist>


<note><para> If no <option>mh_jscale</option> parameter is used in estimated_params, the procedure uses <option>mh_jscale</option> for all parameters. If <option>mh_jscale</option> option isn't set, the procedure uses <literal>0.2</literal> for all parameters.
</para></note>
</refsect1>

<refsect1><title>Results</title>
<itemizedlist spacing='compact'>
<listitem><para> results from posterior optimization (also for maximum likelihood)</para></listitem>
<listitem><para> marginal log density</para></listitem>
<listitem><para> mean and shortest confidence interval from posterior simulation</para></listitem>
<listitem><para>Metropolis-Hastings convergence graphs that still need to be documented</para></listitem>
<listitem><para> graphs with prior, posterior and mode</para></listitem>
<listitem><para> graphs of smoothed shocks, smoothed observation errors, smoothed and historical variables</para></listitem>
</itemizedlist>
</refsect1>

<refsect1><title>Output</title>
<para>After running <command>estimation</command>, the parameters and the variance matrix of the shocks are set to the mode for maximum likelihood estimation or posterior mode computation without Metropolis iterations.
</para>
<para>After <command>estimation</command> with Metropolis iterations (option <option>mh_replic</option> > 0 or option <option>load_mh_file</option> set) the parameters and the variance matrix of the shocks are set to the posterior mean.</para>

<para>Depending on the options, <command>estimation</command> stores results in the following fields of structure <varname>oo_</varname>:
<table orient="land"><title>Content of <varname>oo_</varname></title><tgroup cols='6'>
<thead>
<row><entry>Field 1</entry><entry>Field 2</entry><entry>Field 3</entry><entry>Field 4</entry><entry>Field 5</entry><entry>Required options</entry></row>
</thead>
<tbody>
<row><entry><varname>Forecast</varname></entry><entry>See <xref linkend="ForecastsMoments"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><xref linkend="forecast_opt"/></entry></row>
<row><entry morerows='1'><varname>MarginalDensity</varname></entry><entry><varname>LaplaceApproximation</varname></entry><entry/><entry></entry><entry></entry><entry>Always provided</entry></row>
<row><entry><varname>ModifiedHarmonicMean</varname></entry><entry></entry><entry></entry><entry></entry><entry><para><xref linkend="mh_replic"/>&gt; 0 or <xref linkend="load_mh_file"/></para></entry></row>
<row><entry><varname>PosteriorFilteredVariables</varname></entry><entry>See <xref linkend="MomentsNames"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><xref linkend="filtered_vars"/></para></entry></row>
<row><entry><varname>PosteriorIRF</varname></entry><entry><varname>Dsge</varname></entry><entry>See <xref linkend="MomentsNames"/></entry><entry><para>IRF name: name of endogenous variable '_' name of shock</para></entry><entry></entry><entry><xref linkend="bayesian_irf"/></entry></row>
<row><entry><varname>PosteriorSmoothedObservationErrors</varname></entry><entry>See <xref linkend="MomentsNames"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><xref linkend="smoother"/></para></entry></row>
<row><entry><varname>PosteriorSmoothedShocks</varname></entry><entry>See <xref linkend="MomentsNames"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><xref linkend="smoother"/></para></entry></row>
<row><entry><varname>PosteriorSmoothedVariables</varname></entry><entry>See <xref linkend="MomentsNames"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><xref linkend="smoother"/></para></entry></row>
<row><entry><varname>PosteriorTheoreticalMoments</varname></entry><entry>See <xref linkend="TheoreticalMoments"/></entry><entry>See <xref linkend="EstimatedObjects"/></entry><entry>See <xref linkend="MomentsNames"/></entry><entry><replaceable>Variable name</replaceable></entry><entry><xref linkend="moments_varendo"/></entry></row>
<row><entry><varname>posterior_density</varname></entry><entry><replaceable>Parameter name</replaceable></entry><entry></entry><entry></entry><entry></entry><entry><para><xref linkend="mh_replic"/>&gt; 0 or <xref linkend="load_mh_file"/></para></entry></row>
<row><entry><varname>posterior_hpdinf</varname></entry><entry>See <xref linkend="EstimatedObjects"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><xref linkend="mh_replic"/>&gt; 0 or <xref linkend="load_mh_file"/></para></entry></row>
<row><entry><varname>posterior_hpdsup</varname></entry><entry>See <xref linkend="EstimatedObjects"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><xref linkend="mh_replic"/>&gt; 0 or <xref linkend="load_mh_file"/></para></entry></row>
<row><entry><varname>posterior_mean</varname></entry><entry>See <xref linkend="EstimatedObjects"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><xref linkend="mh_replic"/>&gt; 0 or <xref linkend="load_mh_file"/></para></entry></row>
<row><entry><varname>posterior_mode</varname></entry><entry>See <xref linkend="EstimatedObjects"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><xref linkend="mh_replic"/>&gt; 0 or <xref linkend="load_mh_file"/></para></entry></row>
<row><entry><varname>posterior_std</varname></entry><entry>See <xref linkend="EstimatedObjects"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><xref linkend="mh_replic"/>&gt; 0 or <xref linkend="load_mh_file"/></para></entry></row>
</tbody>
</tgroup>
</table>
</para>

<para><anchor id="ForecastsMoments" xreflabel="Moments of forecasts"/>
<table><title>Moments of forecasts</title>
<tgroup cols='2'>
<thead>
<row><entry>Field name</entry><entry>Description</entry></row>
</thead>
<tbody>
<row><entry><varname>HPDinf</varname></entry><entry>Lower bound of a 90% HPD interval<footnote id="see_conf_sig"><para>See option <xref linkend="conf_sig"/> to change the size of the HPD interval</para></footnote> of forecast  due to parameter uncertainty</entry></row> 
<row><entry><varname>HPDsup</varname></entry><entry>Lower bound of a 90% HPD interval <footnoteref linkend="see_conf_sig"/> due to parameter uncertainty</entry></row> 
<row><entry><varname>HPDTotalinf</varname></entry><entry>Lower bound of a 90% HPD interval of forecast <footnoteref linkend="see_conf_sig"/> due to parameter uncertainty and future shocks</entry></row> 
<row><entry><varname>HPDTotalsup</varname></entry><entry>Lower bound of a 90% HPD interval <footnoteref linkend="see_conf_sig"/> due to parameter uncertainty and future shocks</entry></row>
<row><entry><varname>Mean</varname></entry><entry>Mean of the posterior distribution of forecasts</entry></row> 
<row><entry><varname>Median</varname></entry><entry>Median of the posterior distribution of forecasts</entry></row>  
<row><entry><varname>Std</varname></entry> <entry>Standard deviation of the posterior distribution of forecasts</entry></row> 
</tbody>
</tgroup>
</table>
</para>
<para><anchor id="MomentsNames" xreflabel="Moments Names"/>
<table><title>Moments Names</title>
<tgroup cols='2'>
<thead>
<row><entry>Field name</entry><entry>Description</entry></row>
</thead>
<tbody>
<row><entry><varname>HPDinf</varname></entry><entry>Lower bound of a 90% HPD interval<footnote id="see_conf_sig1"><para>See option <xref linkend="conf_sig"/> to change the size of the HPD interval</para></footnote></entry></row> 
<row><entry><varname>HPDsup</varname></entry><entry>Upper bound of a 90% HPD interval <footnoteref linkend="see_conf_sig1"/> </entry></row> 
<row><entry><varname>Mean</varname></entry><entry>Mean of the posterior distribution</entry></row> 
<row><entry><varname>Median</varname></entry><entry>Median of the posterior distribution</entry></row>  
<row><entry><varname>Std</varname></entry> <entry>Standard deviation of the posterior distribution</entry></row> 
</tbody>
</tgroup>
</table>
</para>
<para><anchor id="TheoreticalMoments" xreflabel="Theoretical Moments"/>
<table><title>Theoretical Moments</title>
<tgroup cols='2'>
<thead>
<row><entry>Field name</entry><entry>Description</entry></row>
</thead>
<tbody>
<row><entry><varname>Autocorrelation</varname></entry><entry>Autocorrelation of endogenous variables<footnote><para>The autocorrlation coefficients are computed for the number of periods specified in option <xref linkend="ar"/>.</para></footnote></entry></row>
<row><entry><varname>Correlation</varname></entry><entry>Correlation between two endogenous variables</entry></row>
<row><entry><varname>Decomp</varname></entry><entry>Decomposition of variance<footnote><para>When the shocks are correlated, it is the decomposition of orthogonalized shocks via Cholesky decompostion according to the order of declaration of shocks (see <xref linkend="varexo"/>).</para></footnote> </entry></row>
<row><entry><varname>Expectation</varname></entry><entry>Expectation of endogenous variables</entry></row>
<row><entry><varname>Variance</varname></entry><entry>(co-)variance of endogenous variables</entry></row>
</tbody>
</tgroup>
</table>
</para>

<para><anchor id="EstimatedObjects" xreflabel="Estimated Objects"/>
<table><title>Estimated objects</title>
<tgroup cols='2'>
<thead>
<row><entry>Field name</entry><entry>Description</entry></row>
</thead>
<tbody>
<row><entry><varname>measurement_errors_corr</varname></entry><entry>Correlation between two measurement errors</entry></row>
<row><entry><varname>measurement_errors_std</varname></entry><entry>Standard deviation of measurement errors</entry></row>
<row><entry><varname>parameters</varname></entry><entry>Parameters</entry></row>
<row><entry><varname>shocks_corr</varname></entry><entry>Correlation between two structural shocks</entry></row>
<row><entry><varname>shocks_std</varname></entry><entry>Standard deviation of structural shocks</entry></row>
</tbody>
</tgroup>
</table>
</para>

<refsect2><title>Examples</title>
<para>
<informalexample>
<programlisting>
oo_.posterior_mode.parameters.alp
oo_.posterior_mean.shocks_std.ex
oo_.posterior_hpdsup.measurement_errors_corr.gdp_conso
</programlisting>
</informalexample>
</para>
</refsect2>

</refsect1>

<refsect1><title>Note on steady state computation</title>
<para>If you know how to compute the steady state for your model, you can provide a <trademark class="registered">MATLAB</trademark> function doing the computation instead of using <command>steady</command>. The function should be called with the name of the <filename class="extension">.mod</filename> file followed by <filename>_steadystate</filename>. See <filename>fs2000a_steadystate.m</filename> in <filename>examples/fs2000</filename> directory.
</para>
</refsect1>
</refentry>

<refentry id="prior_analysis">
  <refmeta>
    <refentrytitle>prior_analysis</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>prior_analysis</refname>
    <refpurpose>Prior distribution analysis</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>prior_analysis</command>
      <arg>(<replaceable>OPTION</replaceable><arg rep="repeat">, <replaceable>OPTION</replaceable></arg>)</arg><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1><title>Options</title>
    <variablelist>
      <varlistentry>
        <term><option>nograph</option></term>
        <listitem><para>See <link linkend="nograph">there</link></para></listitem>
      </varlistentry>
      <varlistentry>
        <term><option>conf_sig</option> = <replaceable>DOUBLE</replaceable></term>
        <listitem><para>See <link linkend="conf_sig">there</link></para></listitem>
      </varlistentry>
      <varlistentry>
        <term><option>prior_trunc</option> = <replaceable>DOUBLE</replaceable></term>
        <listitem><para>See <link linkend="prior_trunc">there</link></para></listitem>
      </varlistentry>
      <varlistentry>
        <term><option>bayesian_irf</option></term>
        <listitem><para>See <link linkend="bayesian_irf">there</link></para></listitem>
      </varlistentry>
      <varlistentry>
        <term><option>irf</option> = <replaceable>INTEGER</replaceable></term>
        <listitem><para>See <link linkend="irf">there</link></para></listitem>
      </varlistentry>
      <varlistentry>
        <term><option>tex</option></term>
        <listitem><para>See <link linkend="tex">there</link></para></listitem>
      </varlistentry>
      <varlistentry>
        <term><option>forecast</option> = <replaceable>INTEGER</replaceable></term>
        <listitem><para>See <link linkend="forecast_opt">there</link></para></listitem>
      </varlistentry>
      <varlistentry>
        <term><option>smoother</option></term>
        <listitem><para>See <link linkend="smoother">there</link></para></listitem>
      </varlistentry>
      <varlistentry>
        <term><option>moments_varendo</option></term>
        <listitem><para>See <link linkend="moments_varendo">there</link></para></listitem>
      </varlistentry>
      <varlistentry>
        <term><option>filtered_vars</option></term>
        <listitem><para>See <link linkend="filtered_vars">there</link></para></listitem>
      </varlistentry>
      <varlistentry>
        <term><option>xls_sheet</option> = <replaceable>NAME</replaceable></term>
        <listitem><para>See <link linkend="xls_sheet">there</link></para></listitem>
      </varlistentry>
      <varlistentry>
        <term><option>xls_range</option> = <replaceable>RANGE</replaceable></term>
        <listitem><para>See <link linkend="xls_range">there</link></para></listitem>
      </varlistentry>
      <varlistentry>
        <term><option>filter_step_ahead</option> = [<replaceable>INTEGER_1</replaceable>:<replaceable>INTEGER_2</replaceable>]</term>
        <listitem><para>See <link linkend="filter_step_ahead">there</link></para></listitem>
      </varlistentry>
    </variablelist>
  </refsect1>

</refentry>

<refentry id="posterior_analysis">
  <refmeta>
    <refentrytitle>posterior_analysis</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>posterior_analysis</refname>
    <refpurpose>Posterior distribution analysis</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>posterior_analysis</command>
      <arg>(<replaceable>OPTION</replaceable><arg rep="repeat">, <replaceable>OPTION</replaceable></arg>)</arg><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1><title>Options</title>
    <para>This command accepts exactly the same options than <xref linkend="prior_analysis"/></para>
  </refsect1>
</refentry>

<refentry id="model_comparison">
  <refmeta>
    <refentrytitle>model_comparison</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>model_comparison</refname>
    <refpurpose>Bayesian model comparison</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>model_comparison</command>
      <arg>(<option>marginal_density</option> = <group choice="plain"><arg choice="plain">laplace</arg><arg choice="plain">modifiedharmonicmean</arg></group>)</arg>
      <arg>
	<replaceable>FILENAME</replaceable><arg>(<replaceable>DOUBLE</replaceable>)</arg>
	<arg rep="repeat"><arg>,</arg> <replaceable>FILENAME</replaceable><arg>(<replaceable>DOUBLE</replaceable>)</arg></arg>
      </arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1><title>Description</title>
    <para>This function computes odds ratios and estimate a posterior density over a colletion of models. The priors over models can be specified as the <replaceable>DOUBLE</replaceable> values, otherwise a uniform prior is assumed.</para>
  </refsect1>
</refentry>

<refentry id="shock_decomposition">
  <refmeta>
    <refentrytitle>shock_decomposition</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>shock_decomposition</refname>
    <refpurpose>computes and displays shock decomposition according to the model for a given sample</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>shock_decomposition</command>
      <arg>(<replaceable>OPTION</replaceable><arg rep="repeat">, <replaceable>OPTION</replaceable></arg>)</arg><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Options</title>
<variablelist>
  <varlistentry>
    <term><option>parameters</option> = <replaceable>PARAMETER_NAME</replaceable></term>
    <listitem><para>...</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>shocks</option> = [ [<replaceable>VARIABLE_NAME</replaceable> ...] ; ...]</term>
    <listitem><para>...</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>labels</option> = [<replaceable>VARIABLE_NAME</replaceable> ...]</term>
    <listitem><para>...</para></listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1><title>Description</title>
<para>...</para>
</refsect1>

</refentry>

<refentry id="unit_root_vars">
  <refmeta>
    <refentrytitle>unit_root_vars</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>unit_root_vars</refname>
    <refpurpose>declares unit-root variables for estimation</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>unit_root_vars</command>
      <arg choice="plain">
	      <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg rep="repeat"><arg>,</arg>
	      <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
<command>unit_root_vars</command> is now deprecated and will result in no action, It was used to declare unit-root variables of a model so that a diffuse prior can be used in the initialization of the Kalman filter for these variables only. For stationary variables, the unconditional covariance matrix of these variables is used for initialization. The algorithm to compute a true diffuse prior is taken from <xref linkend="durbin-koopman_2001"/> and <xref linkend="koopman-durbin_2003"/>.
</para>

<para>When <command>unit_root_vars</command> is used the <xref linkend="lik_init"/> option of <xref linkend="estimation"/> has no effect.
</para>

<para>When there are nonstationary variables in a model, there is no unique deterministic steady state. The user must supply a <trademark class="registered">MATLAB</trademark> function that computes the steady state values of the stationary variables in the model and returns dummy values for the nonstationary ones. The function should be called with the name of the <filename>.mod</filename> file followed by <filename>_steadystate</filename>. See <filename>fs2000a_steadystate.m</filename> in <filename>examples/fs2000</filename> directory.
</para>

<para>Note that the nonstationary variables in the model must be integrated processes(their first difference or k-difference must be stationary).</para>
</refsect1>
</refentry>
</sect1>

<sect1><title>Forecasting</title>
<para>On a calibrated model, forecasting is done using the <xref linkend="forecast"/> command. On an estimated command, use the <xref linkend="forecast_opt"/> option of <xref linkend="estimation"/> command.</para>

<para>It is also possible to compute forecasts on a calibrated or estimated model for a given constrained path of the future endogenous variables. This is done, from the reduced form representation of the DSGE model, by finding the structural shocks that are needed to match the restricted paths. Use <xref linkend="conditional_forecast" />, <xref linkend="conditional_forecast_paths" /> and <xref linkend="plot_conditional_forecast" /> for that purpose.</para>

<refentry id="forecast">
  <refmeta>
    <refentrytitle>forecast</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>forecast</refname>
    <refpurpose>computes a simulation of a stochastic model from a given state</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>forecast</command>
      <arg>(<replaceable>OPTION</replaceable><arg rep="repeat">, <replaceable>OPTION</replaceable></arg>)</arg>
      <arg><replaceable>VARIABLE_NAME</replaceable></arg>
      <arg rep="repeat"><arg>,</arg> <replaceable>VARIABLE_NAME</replaceable></arg><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Options</title>
<variablelist>
  <varlistentry>
    <term><option>periods</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Number of periods of the forecast. Default: <literal>40</literal></para></listitem>
  </varlistentry>
  <varlistentry id="conf_sig" xreflabel="conf_sig">
    <term><option>conf_sig</option> = <replaceable>DOUBLE</replaceable></term>
    <listitem><para>Level of significance for confidence interval. Default: <literal>0.90</literal></para></listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1><title>Description</title>
<para><command>forecast</command> computes a simulation of a stochastic model from an arbitrary initial point.</para>
<para>When the model also contains deterministic exogenous shocks, the simulation is computed conditionaly to the agents knowing the future values of the deterministic exogenous variables.</para>

<para><command>forecast</command> must be called after <xref linkend="stoch_simul"/>.</para>

<para><command>forecast</command> plots the trajectory of endogenous variables. When a list of variable names follows the command, only those variables are plotted. A 90% confidence interval is plotted around the mean trajectory. Use option <option>conf_sig</option> to change the level of the confidence interval.</para>
</refsect1>

<refsect1><title>Output variables</title>
<para>The following variables are set in structure <varname>oo_</varname>:
<itemizedlist spacing="compact">
<listitem><para><varname>oo_.forecast.Mean.<replaceable>VARIABLE_NAME</replaceable></varname>: mean forecast of endogenous variables</para></listitem>
<listitem><para><varname>oo_.forecast.HPDinf.<replaceable>VARIABLE_NAME</replaceable></varname>: lower bound of a confidence interval around the forecast</para></listitem>
<listitem><para><varname>oo_.forecast.HPDsup.<replaceable>VARIABLE_NAME</replaceable></varname>: upper bound of a confidence interval around the forecast</para></listitem>
<listitem><para><varname>oo_.forecast.Exogenous.<replaceable>VARIABLE_NAME</replaceable></varname>: trajectory of the deterministic exogenous variables</para></listitem>
</itemizedlist>
</para>
</refsect1>


<refsect1><title>Example</title>
<informalexample>
  <programlisting>
varexo_det tau;
varexo e;

...

shocks;
var e; stderr 0.01;
var tau;
periods 1:9;
values -0.15;
end;

stoch_simul(irf=0);

forecast;
  </programlisting>
</informalexample>
</refsect1>
</refentry>

<refentry id="conditional_forecast">
  <refmeta>
    <refentrytitle>conditional_forecast</refentrytitle>
  </refmeta>
  
  <refnamediv>
    <refname>conditional_forecast</refname>
    <refpurpose>computes a simulation of a stochastic model conditionally to a specified future path for some endogenous variables.</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>conditional_forecast</command>
      <arg>(<replaceable>OPTION</replaceable><arg rep="repeat">, <replaceable>OPTION</replaceable></arg>)</arg>
      <arg choice="plain"><replaceable>VARIABLE_NAME</replaceable></arg>
      <arg rep="repeat"><arg>,</arg> <replaceable>VARIABLE_NAME</replaceable></arg><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Options</title>
<variablelist>
  <varlistentry>
    <term><option>parameter_set</option> = <option>prior_mode</option> | <option>prior_mean</option> | <option>posterior_mode</option> | 
    <option>posterior_mean</option> | <option>posterior_median</option></term>
    <listitem><para>Specify the parameter set to use for the forecasting. No default value,  mandatory option.</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>controlled_varexo</option> = (<replaceable>VARIABLE_NAME</replaceable> [ [,] <replaceable>VARIABLE_NAME</replaceable> ... ] )</term>
    <listitem><para>Specify the exogenous variables to use as control variables. No default value, mandatory option.</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>periods</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Number of periods of the forecast. Default: <literal>40</literal>. 
    <option>periods</option> cannot be less than the number of constrained periods. </para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>replic</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Number of simulations. Default: <literal>5000</literal>.</para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>conf_sig</option> = <replaceable>DOUBLE</replaceable></term>
    <listitem><para>Level of significance for confidence interval. Default: <literal>0.80</literal></para></listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1><title>Description</title>
<para><command>conditional_forecast</command> computes forecasts on an estimated model for a given constrained path of some 
future endogenous variables. This is done, from the reduced form representation of the DSGE model, by finding the structural shocks that 
are needed to match the restricted paths. This command has to be called after estimation.</para>

<para>Use <xref linkend="conditional_forecast_paths" /> to give the list of constrained endogenous, and their constrained future path. Option <option>controlled_varexo</option> is used to specify the structural shocks which will be matched to generate the constrained path.</para>

<para>Use <xref linkend="plot_conditional_forecast" /> to graph the results.</para>

</refsect1>

<refsect1><title>Example</title>
<informalexample>
  <programlisting>
var y a
varexo e u;

...

estimation(...);

conditional_forecast_paths;
var y;
periods 1:3, 4:5;
values 2, 5;
var a;
periods 1:5;
values 3;
end;

conditional_forecast(parameter_set = calibration, controlled_varexo = (e, u), replic = 3000);

plot_conditional_forecast(periods = 10) e u;
  </programlisting>
</informalexample>
</refsect1>
</refentry>

<refentry id="conditional_forecast_paths">
  <refmeta>
    <refentrytitle>conditional_forecast_paths</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>conditional_forecast_paths</refname>
    <refpurpose>in a conditional forecast, gives the list of constrained endogenous and their path</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>conditional_forecast_paths</command><arg choice="plain">;</arg><sbr/>
      <arg rep="repeat">
	      <arg choice="plain">var <replaceable>VARIABLE_NAME</replaceable>;</arg>
	      <arg choice="plain">periods <replaceable>INTEGER</replaceable><arg>:<replaceable>INTEGER</replaceable></arg><arg rep="repeat"><arg>,</arg> <replaceable>INTEGER</replaceable><arg>:<replaceable>INTEGER</replaceable></arg></arg>;</arg>
        <arg choice="plain">values <replaceable>EXPRESSION</replaceable> <arg rep="repeat"><arg>,</arg> <replaceable>EXPRESSION</replaceable></arg>;</arg>
      </arg><sbr/>
      <command>end</command><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>Describes the path of constrained endogenous, before calling <xref linkend="conditional_forecast"/>. The syntax is similar to deterministic shocks in <xref linkend="shocks"/>, see <xref linkend="conditional_forecast"/> for an example.</para>
</refsect1>
</refentry>

<refentry id="plot_conditional_forecast">
  <refmeta>
    <refentrytitle>plot_conditional_forecast</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>plot_conditional_forecast</refname>
    <refpurpose>plots the conditional forecasts</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>plot_conditional_forecast</command>
      <arg>(<option>periods</option> = <replaceable>INTEGER</replaceable>)</arg><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Options</title>
<variablelist>
  <varlistentry>
    <term><option>periods</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Number of periods to be plotted. Default: equal to <option>periods</option> in <command>conditional_forecast</command>. The number of periods 
    declared in <command>plot_conditional_forecast</command> cannot be greater than the one declared in <command>conditional_forecast</command>.</para></listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1><title>Description</title>
<para>
To be used after <xref linkend="conditional_forecast"/>.
</para>
</refsect1>
</refentry>
</sect1>

<sect1><title>Optimal policy</title>
<para>Dynare has tools to compute optimal policies for quadratic objectives. You can either solve for optimal policy under commitment with <command>planner_objective</command> or for optimal simple rule with <xref linkend='osr'/>.
</para>

<itemizedlist>
<listitem><para><xref linkend='optim_weights'/></para></listitem>
<listitem><para><xref linkend='osr'/></para></listitem>
<listitem><para><xref linkend='osr_params'/></para></listitem>
<listitem><para><xref linkend='planner_objective'/></para></listitem>
<listitem><para><xref linkend='ramsey_policy'/></para></listitem>
</itemizedlist>

<refentry id="optim_weights">
  <refmeta>
    <refentrytitle>optim_weights</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>optim_weights</refname>
    <refpurpose>specifies quadratic objectives for optimal policy problems</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>optim_weights</command><arg choice="plain">;</arg><sbr/>
      <arg rep="repeat">
	      <group choice="plain">
          <arg choice="plain"><replaceable>VARIABLE_NAME</replaceable> <replaceable>EXPRESSION</replaceable>;</arg>
          <arg choice="plain"><replaceable>VARIABLE_NAME</replaceable>, <replaceable>VARIABLE_NAME</replaceable> <replaceable>EXPRESSION</replaceable>;</arg>
        </group>
      </arg>
      <command>end</command><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>


<refsect1><title>Description</title>
<para>
<command>optim_weights</command> secifies the nonzero elements of the quadratic weight matrices for the objectives in <xref linkend='osr'/>.
</para>
</refsect1>
</refentry>

<refentry id="osr">
  <refmeta>
    <refentrytitle>osr</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>osr</refname>
    <refpurpose>computes optimal simple policy rules</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>osr</command>
      <arg>(<replaceable>OPTION</replaceable><arg rep="repeat">, <replaceable>OPTION</replaceable></arg>)</arg>
      <arg rep="repeat"><replaceable>VARIABLE_NAME</replaceable></arg><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Options</title>
<para>All options for <xref linkend="stoch_simul"/>.</para>
</refsect1>

<refsect1><title>Description</title>
<para>
<command>osr</command> computes optimal simple policy rules for linear--quadratic problems of the form:
</para>
<blockquote><para>
max<subscript>&gamma;</subscript> E(y'<subscript>t</subscript>Wy<subscript>t</subscript>)
</para>
<para>s.t.</para>
<para>
  A<subscript>1</subscript>E<subscript>t</subscript>(y<subscript>t+1</subscript>)+A<subscript>2</subscript>y<subscript>t</subscript>+A<subscript>3</subscript>y<subscript>t-1</subscript>+Ce<subscript>t</subscript>=0
</para>
</blockquote>
<para>with:</para>
<itemizedlist>
<listitem><para>&gamma;: parameters to be optimized. They must be elements of matrices A<subscript>1</subscript>, A<subscript>2</subscript>, A<subscript>3</subscript>.</para></listitem>
<listitem><para>y: endogenous variables</para></listitem>
<listitem><para>e: exogenous stochastic shocks</para></listitem>
</itemizedlist>
<para>The parameters to be optimized must be listed with <xref linkend='osr_params'/>.
</para>
<para>The quadratic objectives must be listed with <xref linkend='optim_weights'/>.
</para>
<para>
This problem is solved using a numerical optimizer.
</para>
</refsect1>
</refentry>

<refentry id="osr_params">
  <refmeta>
    <refentrytitle>osr_params</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>osr_params</refname>
    <refpurpose>declares the parameters to be optimized for optimal simple rules</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>osr_params</command>
      <arg choice="plain"><replaceable>PARAMETER_NAME</replaceable></arg>
      <arg rep="repeat"><replaceable>PARAMETER_NAME</replaceable></arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>


<refsect1><title>Description</title>
<para>
<command>osr_params</command> declares parameters to be optimized  by <xref linkend='osr'/>.
</para>
</refsect1>
</refentry>

<refentry id="planner_objective">
  <refmeta>
    <refentrytitle>planner_objective</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>planner_objective</refname>
    <refpurpose>declares the policy maker objective, for use with <xref linkend="ramsey_policy"/></refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>planner_objective</command>
      <arg choice="plain"><replaceable>MODEL_EXPRESSION</replaceable></arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1><title>Description</title>
  <para>...</para>
  </refsect1>

</refentry>

<refentry id="ramsey_policy">
  <refmeta>
    <refentrytitle>ramsey_policy</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>ramsey_policy</refname>
    <refpurpose>computes the first order approximation of the policy that maximizes the policy maker objective function (see <xref linkend="planner_objective"/>) submitted to the constraints provided by the equilibrium path of the economy</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>ramsey_policy</command>
      <arg>(<replaceable>OPTION</replaceable><arg rep="repeat">, <replaceable>OPTION</replaceable></arg>)</arg>
      <arg rep="repeat"><replaceable>VARIABLE_NAME</replaceable></arg><arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Options</title>

<para>All options for <xref linkend="stoch_simul"/>, plus:</para>
<variablelist>
  <varlistentry>
    <term><option>planner_discount</option> = <replaceable>DOUBLE</replaceable></term>
    <listitem><para>Declares the discount factor of the central planner. Default: <literal>1.0</literal></para></listitem>
  </varlistentry>
</variablelist>
</refsect1>

</refentry>

</sect1>

<sect1><title>Sensitivity and identification analysis</title>

<refentry id="dynare_sensitivity">
  <refmeta>
    <refentrytitle>dynare_sensitivity</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>dynare_sensitivity</refname>
    <refpurpose>interface to the global sensitivity analysis (GSA) toolbox</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>dynare_sensitivity</command>
      <arg>(<replaceable>OPTION</replaceable><arg rep="repeat">, <replaceable>OPTION</replaceable></arg>)</arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>This function is an interface to the global sensitivity analysis (GSA) toolbox developed by the Joint Research Center (JRC) of the European Commission. The GSA toolbox needs to be downloaded separately from the <ulink url="http://eemc.jrc.ec.europa.eu/Software-DYNARE.htm">JRC web site</ulink>.</para>
</refsect1>

<refsect1><title>Options</title>
<para>Please refer to the documentation of the GSA toolbox on the official website.</para>
</refsect1>

</refentry>

<refentry id="identification">
  <refmeta>
    <refentrytitle>identification</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>identification</refname>
    <refpurpose>triggers identification analysis</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>identification</command>
      <arg>(<replaceable>OPTION</replaceable><arg rep="repeat">, <replaceable>OPTION</replaceable></arg>)</arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Options</title>
<variablelist>
  <varlistentry>
    <term><option>ar</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Number of lags of computed autocorrelations (theoretical moments). Default: <literal>3</literal></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>useautocorr</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>If equal to <literal>1</literal>, compute derivatives of autocorrelation. If equal to <literal>0</literal>, compute derivatives of autocovariances. Default: <literal>1</literal></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>load_ident_files</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>If equal to <literal>1</literal>, allow Dynare to load previously 
computed analyzes. Default: <literal>0</literal></para></listitem>
  </varlistentry>
  <varlistentry>
    <term><option>prior_mc</option> = <replaceable>INTEGER</replaceable></term>
    <listitem><para>Size of Monte Carlo sample. Default: <literal>2000</literal></para></listitem>
  </varlistentry>
</variablelist>
</refsect1>

</refentry>

</sect1>

<sect1><title>Displaying and saving results</title>
<para>
Dynare has comments to plot the results of a simulation and to save the results.
</para>
<itemizedlist>
<listitem><para><xref linkend='rplot'/></para></listitem>
<listitem><para><xref linkend='dynatype'/></para></listitem>
<listitem><para><xref linkend='dynasave'/></para></listitem>
</itemizedlist>

<refentry id="rplot">
  <refmeta>
    <refentrytitle>rplot</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>rplot</refname>
    <refpurpose>plot variables</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>rplot</command>
      <arg choice="plain"><replaceable>VARIABLE_NAME</replaceable></arg>
      <arg rep="repeat"><replaceable>VARIABLE_NAME</replaceable></arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>
<refsect1><title>Description</title>
<para>
Plots the simulated path of one or several variables.
</para>
</refsect1>
</refentry>

<refentry id="dynatype">
  <refmeta>
    <refentrytitle>dynatype</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>dynatype</refname>
    <refpurpose>print simulated variables</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>dynatype</command>
      <arg choice="plain">(<replaceable>FILENAME</replaceable>)</arg>
      <arg rep="repeat"><replaceable>VARIABLE_NAME</replaceable></arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
<command>dynatype</command> prints the listed variables in a text file named <replaceable>FILENAME</replaceable>. If no <replaceable>VARIABLE_NAME</replaceable> is listed, all endogenous variables are printed.
</para>
</refsect1>

</refentry>

<refentry id="dynasave">
  <refmeta>
    <refentrytitle>dynasave</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>dynasave</refname>
    <refpurpose>save simulated variables in a binary file</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>dynasave</command>
      <arg choice="plain">(<replaceable>FILENAME</replaceable>)</arg>
      <arg rep="repeat"><replaceable>VARIABLE_NAME</replaceable></arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
<command>dynasave</command> saves the listed variables in a binary file named <replaceable>FILENAME</replaceable>. If no <replaceable>VARIABLE_NAME</replaceable> are listed, all endogenous variables are saved.
</para>
<para>
In <trademark class="registered">MATLAB</trademark>, variables saved with the <command>dynasave</command> command can be retrieved by the <trademark class="registered">MATLAB</trademark> command <command>load -mat <replaceable>FILENAME</replaceable></command>.
</para>
</refsect1>
</refentry>
</sect1>

<sect1 id="macrolanguage"><title>Macro-processing language</title>
<para>It is possible to use "macro" commands in the <filename class="extension">.mod</filename> file for doing the following tasks: source file inclusion, replicating blocks of equations through loops, conditional inclusion of code...</para>

<para>Technically, this macro language is totally independent of the basic Dynare language, and is processed by a separate component of the Dynare pre-processor. The macro processor transforms a <filename class="extension">.mod</filename> file with macros into a <filename class="extension">.mod</filename> file without macros (doing expansions/inclusions), and then feeds it to the Dynare parser.
</para>
<itemizedlist>
<listitem><para><xref linkend='include'/></para></listitem>
<listitem><para><xref linkend='define'/></para></listitem>
<listitem><para><xref linkend='if_else_endif'/></para></listitem>
<listitem><para><xref linkend='for_endfor'/></para></listitem>
<listitem><para><xref linkend='echo'/></para></listitem>
<listitem><para><xref linkend='error'/></para></listitem>
</itemizedlist>

<refentry id="include">
  <refmeta>
    <refentrytitle>@#include</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>@#include</refname>
    <refpurpose>includes another file</refpurpose>
  </refnamediv>

  <refsect1><title>Description</title>
  <para>...</para>
  </refsect1>

</refentry>

<refentry id="define">
  <refmeta>
    <refentrytitle>@#define</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>@#define</refname>
    <refpurpose>defines a macro-variable</refpurpose>
  </refnamediv>

  <refsect1><title>Description</title>
  <para>...</para>
  </refsect1>

</refentry>

<refentry id="if_else_endif">
  <refmeta>
    <refentrytitle>@#if ... @#else ... @#endif</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>@#if ... @#else ... @#endif</refname>
    <refpurpose>conditional inclusion of some part of the <filename class="extension">.mod</filename> file</refpurpose>
  </refnamediv>

  <refsect1><title>Description</title>
  <para>...</para>
  </refsect1>

</refentry>

<refentry id="for_endfor">
  <refmeta>
    <refentrytitle>@#for ... @#endfor</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>@#for ... @#endfor</refname>
    <refpurpose>loop for replications of portions of the <filename class="extension">.mod</filename> file</refpurpose>
  </refnamediv>

  <refsect1><title>Description</title>
  <para>...</para>
  </refsect1>
</refentry>

<refentry id="echo">
  <refmeta>
    <refentrytitle>@#echo</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>@#echo</refname>
    <refpurpose>asks the preprocessor to display some message on standard output</refpurpose>
  </refnamediv>

  <refsect1><title>Description</title>
  <para>...</para>
  </refsect1>

</refentry>

<refentry id="error">
  <refmeta>
    <refentrytitle>@#error</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>@#error</refname>
    <refpurpose>asks the preprocessor to display some error message on standard output and to abort</refpurpose>
  </refnamediv>

  <refsect1><title>Description</title>
  <para>...</para>
  </refsect1>

</refentry>

</sect1>

<sect1><title>Misc commands</title>

<itemizedlist>
  <listitem><para><xref linkend="save_params_and_steady_state"/></para></listitem>
  <listitem><para><xref linkend="load_params_and_steady_state"/></para></listitem>
  <listitem><para><xref linkend="bvar_density"/></para></listitem>
  <listitem><para><xref linkend="bvar_forecast"/></para></listitem>
</itemizedlist>

<refentry id="save_params_and_steady_state">
  <refmeta>
    <refentrytitle>save_params_and_steady_state</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>save_params_and_steady_state</refname>
    <refpurpose>saves the values of the parameters and of the computed steady-state in a file</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>save_params_and_steady_state</command>
      <arg choice="plain"><replaceable>FILENAME</replaceable></arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>
    <title>Description</title>
    <para>For all parameters, endogenous and exogenous variables, stores
      their value in a text file, using a simple name/value associative table.</para>
    <itemizedlist>
      <listitem><para>for parameters, the value is taken from the last parameter
          initialization</para></listitem>
      <listitem><para>for exogenous, the value is taken from the last initval block</para></listitem>
      <listitem><para>for endogenous, the value is taken from the last steady state computation
          (or, if no steady state has been computed, from the last initval block)</para></listitem>
    </itemizedlist>
    <para>Note that no variable type is stored in the file, so that the values
      can be reloaded (with <xref linkend="load_params_and_steady_state"/>) in a setup where
      the variable types are different.</para>
    <para>The typical usage of this function is to compute the steady-state of a
      model by calibrating the steady-state value of some endogenous variables (which implies that some parameters must be endogeneized
      during the steady-state computation).</para>
    <para>You would then write a first <filename class="extension">.mod</filename> file which computes the steady state and saves the result of the
      computation at the end of the file, using <command>save_params_and_steady_state</command>.</para>
    <para>In a second file designed to perform the actual simulations, you would use <xref linkend="load_params_and_steady_state"/> just after
      your variable declarations, in order to load the steady state previously computed (including the parameters which had been
      endogeneized during the steady state computation).</para>
    <para>The need for two separate <filename class="extension">.mod</filename> files arises from the fact that the variable declarations differ between the files for
      steady state calibration and for simulation (the set of endogenous and parameters differ between the two); this leads
      to different <xref linkend="var"/> and <xref linkend="parameters"/> statements.</para>
    <para>Also note that you can take advantage of the <xref linkend="include"/> directive to share the model equations between the two files.</para>
  </refsect1>
</refentry>

<refentry id="load_params_and_steady_state">
  <refmeta>
    <refentrytitle>load_params_and_steady_state</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>load_params_and_steady_state</refname>
    <refpurpose>loads the values of the parameters and of the steady-state from a file</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>load_params_and_steady_state</command>
      <arg choice="plain"><replaceable>FILENAME</replaceable></arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>
    <title>Description</title>
    <para>For all parameters, endogenous and exogenous variables, loads
      their value from a file created with <command>save_params_and_steady_state</command>.</para>
    <itemizedlist>
      <listitem><para>for parameters, their value will be initialized as if they
          had been calibrated in the <filename class="extension">.mod</filename> file</para></listitem>
      <listitem><para>for endogenous and exogenous, their value will be initialized
          as they would have been from an initval block</para></listitem>
    </itemizedlist>
    <para>This function is used in conjunction with <xref linkend="save_params_and_steady_state"/>;
      see the documentation of that function for more information.</para>
  </refsect1>
</refentry>

<refentry id="bvar_density">
  <refmeta>
    <refentrytitle>bvar_density</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>bvar_density</refname>
    <refpurpose>computes the marginal density of an estimated BVAR model, using Minnesota priors</refpurpose>
  </refnamediv>

  <refsect1><title>Description</title>
  <para>...</para>
  </refsect1>

</refentry>

<refentry id="bvar_forecast">
  <refmeta>
    <refentrytitle>bvar_forecast</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>bvar_forecast</refname>
    <refpurpose>computes in-sample or out-sample forecasts for an estimated BVAR model, using Minnesota priors</refpurpose>
  </refnamediv>

  <refsect1><title>Description</title>
  <para>...</para>
  </refsect1>

</refentry>

</sect1>

</chapter>

<bibliography>

<biblioentry id="boucekkine_1995" xreflabel="Boucekkine (1995)">
  <biblioset relation="article">
    <author>
      <surname>Boucekkine</surname>
      <firstname>Raouf</firstname>
    </author>
    <pubdate>1995</pubdate>
    <title>An alternative methodology for solving nonlinear forward-looking models</title>
  </biblioset>
  <biblioset relation="journal">
    <title>Journal of Economic Dynamics and Control</title>
    <volumenum>19</volumenum>
    <pagenums>711-734</pagenums>
  </biblioset>
</biblioentry>

<biblioentry id="collard-juillard_2001a" xreflabel="Collard and Juillard (2001a)">
  <biblioset relation="article">
    <authorgroup>
      <author>
	<surname>Collard</surname>
	<firstname>Fabrice</firstname>
      </author>
      <author>
	<surname>Juillard</surname>
	<firstname>Michel</firstname>
      </author>
    </authorgroup>
    <pubdate>2001</pubdate>
    <title>Accuracy of stochastic perturbation methods: The case of asset pricing models</title>
  </biblioset>
  <biblioset relation="journal">
    <title>Journal of Economic Dynamics and Control</title>
    <volumenum>25</volumenum>
    <pagenums>979-999</pagenums>
  </biblioset>
</biblioentry>

<biblioentry id="collard-juillard_2001b" xreflabel="Collard and Juillard (2001b)">
  <biblioset relation="article">
    <authorgroup>
      <author>
	<surname>Collard</surname>
	<firstname>Fabrice</firstname>
      </author>
      <author>
	<surname>Juillard</surname>
	<firstname>Michel</firstname>
      </author>
    </authorgroup>
    <pubdate>2001</pubdate>
    <title>A Higher-Order Taylor Expansion Approach to Simulation of Stochastic Forward-Looking Models with an Application to a Non-Linear Phillips Curve</title>
  </biblioset>
  <biblioset relation="journal">
    <title>Computational Economics</title>
    <volumenum>17</volumenum>
    <pagenums>125-139</pagenums>
  </biblioset>
</biblioentry>

<biblioentry id="durbin-koopman_2001" xreflabel="Durbin and Koopman (2001)">
  <biblioset relation="book">
    <authorgroup>
      <author>
	<surname>Durbin</surname>
	<firstname>J.</firstname>
      </author>
      <author>
	<surname>Koopman</surname>
	<firstname>S.J.</firstname>
      </author>
    </authorgroup>
    <pubdate>2001</pubdate>
    <title>Time Series Analysis by State Space Methods</title>
    <publishername>Oxford University Press</publishername>
  </biblioset>
</biblioentry>

<biblioentry id="fair-taylor_1983" xreflabel="Fair and Taylor (1983)">
  <biblioset relation="article">
    <authorgroup>
      <author>
	<surname>Fair</surname>
	<firstname>Ray</firstname>
      </author>
      <author>
	<surname>Taylor</surname>
	<firstname>John</firstname>
      </author>
    </authorgroup>
    <pubdate>1983</pubdate>
    <title>Solution and Maximum Likelihood Estimation of Dynamic Nonlinear Rational Expectation Models</title>
  </biblioset>
  <biblioset relation="journal">
    <title>Econometrica</title>
    <volumenum>51</volumenum>
    <pagenums>1169-1185</pagenums>
  </biblioset>
</biblioentry>

<biblioentry>
  <biblioset relation="article">
    <authorgroup>
      <author>
	<surname>Fernandez-Villaverde</surname>
	<firstname>Jesus</firstname>
      </author>
      <author>
	<surname>Rubio-Ramirez</surname>
	<firstname>Juan</firstname>
      </author>
    </authorgroup>
    <pubdate>2004</pubdate>
    <title>Comparing Dynamic Equilibrium Economies to Data: A Bayesian Approach</title>
  </biblioset>
  <biblioset relation="journal">
  <title>Journal of Econometrics</title>
  <volumenum>123</volumenum>
    <pagenums>153-187</pagenums>
  </biblioset>
</biblioentry>

<biblioentry id="ireland_2004" xreflabel="Ireland (2004)">   
  <biblioset relation="article">
    <author>
      <surname>Ireland</surname>
      <firstname>Peter</firstname>
    </author>
    <pubdate>2004</pubdate>
    <title>A Method for Taking Models to the Data</title>
  </biblioset>
  <biblioset relation="journal">
    <title>Journal of Economic Dynamics and Control</title>
    <volumenum>28</volumenum>
    <pagenums>1205-26</pagenums>
  </biblioset>
</biblioentry>

<biblioentry id="judd_1996" xreflabel="Judd (1996)">  
  <biblioset relation="article">
    <author>
      <surname>Judd</surname>
      <firstname>Kenneth</firstname>
    </author>
    <pubdate>1996</pubdate>    
    <title>Approximation, Perturbation, and Projection Methods in Economic Analysis</title>
  </biblioset>

  <biblioset relation="book">
    <authorgroup>
      <author>
	<surname>Amman</surname>
	<firstname>Hans</firstname>
      </author>
      <author>
	<surname>Kendrick</surname>
	<firstname>David</firstname>
      </author>
      <author>
	<surname>Rust</surname>
	<firstname>John</firstname>
      </author>
    </authorgroup>
    <title>Handbook of Computational Economics</title>
    <pubdate>1996</pubdate>
    <publishername>North Holland Press</publishername>
    <pagenums>511-585</pagenums>
  </biblioset>
</biblioentry>

<biblioentry id="juillard_1996" xreflabel="Juillard (1996)">
  <biblioset relation="article">
    <author>
      <surname>Juillard</surname>
      <firstname>Michel</firstname>
    </author>
    <pubdate>1996</pubdate>
    <title>Dynare: A program for the resolution and simulation of dynamic models with forward variables through the use of a relaxation algorithm</title>
  </biblioset>
  <biblioset relation="wpseries">
    <orgname>CEPREMAP</orgname>
    <title>Couverture Orange</title>
    <volumenum>9602</volumenum>
  </biblioset>
</biblioentry>

<biblioentry id="koopman-durbin_2003" xreflabel="Koopman and Durbin (2003)">
  <biblioset relation="article">
    <authorgroup>
      <author>
	<surname>Koopman</surname>
	<firstname>S.J.</firstname>
      </author>
      <author>
	<surname>Durbin</surname>
	<firstname>J.</firstname>
      </author>
    </authorgroup>
    <pubdate>2003</pubdate>
    <title>Filtering and Smoothing of State Vector for Diffuse State Space Models</title>
  </biblioset>
  <biblioset relation="journal">
    <title>Journal of Time Series Analysis</title>
    <volumenum>24</volumenum>
    <issuenum>1</issuenum>
    <pagenums>85-98</pagenums>
  </biblioset>
</biblioentry>

<biblioentry id="laffargue_1990" xreflabel="Laffargue (1990)">
  <biblioset relation="article">
    <author>
      <surname>Laffargue</surname>
      <firstname>Jean-Pierre</firstname>
    </author>
    <title>Résolution d'un modèle macroéconomique avec anticipations rationnelles</title>
    <pubdate>1990</pubdate>
  </biblioset>
  <biblioset relation="journal">
    <title>Annales d'Économie et Statistique</title>
    <volumenum>17</volumenum>
    <pagenums>97-119</pagenums>
  </biblioset>
</biblioentry>

<biblioentry> 
  <biblioset relation="article">
    <authorgroup>
      <author>
        <surname>Lubik</surname>
        <firstname>Thomas</firstname>
      </author>
      <author>
        <surname>Schorfheide</surname>
        <firstname>Frank</firstname>
      </author>
    </authorgroup>
    <pubdate>2007</pubdate>
    <title>Do Central Banks Respond to Exchange Rate Movements? A Structural Investigation</title>
  </biblioset>
  <biblioset relation="journal">
    <title>Journal of Monetary Economics</title>
    <volumenum>54</volumenum>
    <issuenum>4</issuenum>
    <pagenums>1069-1087</pagenums>
  </biblioset>
</biblioentry>

<biblioentry id="bib_userguide" xreflabel="Mancini-Griffoli (2007)">
  <author>
    <surname>Mancini-Griffoli</surname>
    <firstname>Tommaso</firstname>
  </author>
  <pubdate>2007</pubdate>
  <title>Dynare User Guide</title>
  <subtitle>An introduction to the solution and estimation of DSGE models</subtitle>
</biblioentry>

<biblioentry id="rabanal-rubio-ramirez_2003" xreflabel="Rabanal and Rubio-Ramirez (2003)"> 
  <biblioset relation="article">
    <authorgroup>
      <author>
        <surname>Rabanal</surname>
        <firstname>Pau</firstname>
      </author>
      <author>
        <surname>Rubio-Ramirez</surname>
        <firstname>Juan</firstname>
      </author>
    </authorgroup>
    <pubdate>2003</pubdate>
    <title>Comparing New Keynesian Models of the Business Cycle: A Bayesian Approach</title>
  </biblioset>
  <biblioset relation="wpseries">
    <orgname>Federal Reserve of Atlanta</orgname>
    <title>Working Paper Series</title>
    <volumenum>2003-30</volumenum>
  </biblioset>
</biblioentry>

<biblioentry id="schorfheide_2000" xreflabel="Schorfheide (2000)"> 
  <biblioset relation="article">
    <author>
      <surname>Schorfheide</surname>
      <firstname>Frank</firstname>
    </author>
  <pubdate>2000</pubdate>
  <title>Loss Function-based evaluation of DSGE models</title>
  </biblioset>
  <biblioset relation="journal">
    <title>Journal of Applied Econometrics</title>
    <volumenum>15</volumenum>
    <pagenums>645-70</pagenums>
  </biblioset>
</biblioentry>

<biblioentry id="schmitt-grohe-uribe_2002" xreflabel="Schmitt-Grohe and Uribe (2002)">
  <biblioset relation="article">
    <authorgroup>
      <author>
        <surname>Schmitt-Grohe</surname>
        <firstname>Stephanie</firstname>
      </author>
      <author>
        <surname>Uribe</surname>
        <firstname>Martin</firstname>
      </author>
    </authorgroup>
    <pubdate>2002</pubdate>
    <title>Solving Dynamic General Equilibrium Models Using a Second-Order Approximation to the Policy Function</title>
  </biblioset>
  <biblioset relation="wpseries">
    <title>NBER Technical Working Papers</title>
    <volumenum>0282</volumenum>
  </biblioset>
</biblioentry>

<biblioentry id="smets-wouters_2003" xreflabel="Smets and Wouters (2003)">
  <biblioset relation="article">
    <authorgroup>
      <author>
        <surname>Smets</surname>
        <firstname>Frank</firstname>
      </author>
      <author>
        <surname>Wouters</surname>
      <firstname>Rafael</firstname>
      </author>
    </authorgroup>
    <pubdate>2003</pubdate>
    <title>An Estimated Dynamic Stochastic General Equilibrium Model of the Euro Area</title>
  </biblioset>
  <biblioset relation="journal">
    <title>Journal of the European Economic Association</title>
    <volumenum>1</volumenum>
    <issuenum>5</issuenum>
    <pagenums>1123-1175</pagenums>
  </biblioset>
</biblioentry>

</bibliography>
</book>

